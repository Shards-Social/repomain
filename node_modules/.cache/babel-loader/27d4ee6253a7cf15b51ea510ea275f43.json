{"ast":null,"code":"function assertNonEmptyString(str) {\n  if (typeof str !== 'string' || !str) {\n    throw new Error('expected a non-empty string, got: ' + str);\n  }\n}\nfunction assertNumber(number) {\n  if (typeof number !== 'number') {\n    throw new Error('expected a number, got: ' + number);\n  }\n}\nconst DB_VERSION_CURRENT = 1;\nconst DB_VERSION_INITIAL = 1;\nconst STORE_EMOJI = 'emoji';\nconst STORE_KEYVALUE = 'keyvalue';\nconst STORE_FAVORITES = 'favorites';\nconst FIELD_TOKENS = 'tokens';\nconst INDEX_TOKENS = 'tokens';\nconst FIELD_UNICODE = 'unicode';\nconst INDEX_COUNT = 'count';\nconst FIELD_GROUP = 'group';\nconst FIELD_ORDER = 'order';\nconst INDEX_GROUP_AND_ORDER = 'group-order';\nconst KEY_ETAG = 'eTag';\nconst KEY_URL = 'url';\nconst KEY_PREFERRED_SKINTONE = 'skinTone';\nconst MODE_READONLY = 'readonly';\nconst MODE_READWRITE = 'readwrite';\nconst INDEX_SKIN_UNICODE = 'skinUnicodes';\nconst FIELD_SKIN_UNICODE = 'skinUnicodes';\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json';\nconst DEFAULT_LOCALE = 'en';\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy(arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res;\n}\nfunction uniqEmoji(emojis) {\n  return uniqBy(emojis, _ => _.unicode);\n}\nfunction initialMigration(db) {\n  function createObjectStore(name, keyPath, indexes) {\n    const store = keyPath ? db.createObjectStore(name, {\n      keyPath\n    }) : db.createObjectStore(name);\n    if (indexes) {\n      for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes)) {\n        store.createIndex(indexName, keyPath, {\n          multiEntry\n        });\n      }\n    }\n    return store;\n  }\n  createObjectStore(STORE_KEYVALUE);\n  createObjectStore(STORE_EMOJI, /* keyPath */FIELD_UNICODE, {\n    [INDEX_TOKENS]: [FIELD_TOKENS, /* multiEntry */true],\n    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],\n    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, /* multiEntry */true]\n  });\n  createObjectStore(STORE_FAVORITES, undefined, {\n    [INDEX_COUNT]: ['']\n  });\n}\nconst openReqs = {};\nconst databaseCache = {};\nconst onCloseListeners = {};\nfunction handleOpenOrDeleteReq(resolve, reject, req) {\n  // These things are almost impossible to test with fakeIndexedDB sadly\n  /* istanbul ignore next */\n  req.onerror = () => reject(req.error);\n  /* istanbul ignore next */\n  req.onblocked = () => reject(new Error('IDB blocked'));\n  req.onsuccess = () => resolve(req.result);\n}\nasync function createDatabase(dbName) {\n  const db = await new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);\n    openReqs[dbName] = req;\n    req.onupgradeneeded = e => {\n      // Technically there is only one version, so we don't need this `if` check\n      // But if an old version of the JS is in another browser tab\n      // and it gets upgraded in the future and we have a new DB version, well...\n      // better safe than sorry.\n      /* istanbul ignore else */\n      if (e.oldVersion < DB_VERSION_INITIAL) {\n        initialMigration(req.result);\n      }\n    };\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n  // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n  // No need for removeEventListener, because once the DB can no longer\n  // fire \"close\" events, it will auto-GC.\n  // Unfortunately cannot test in fakeIndexedDB: https://github.com/dumbmatter/fakeIndexedDB/issues/50\n  /* istanbul ignore next */\n  db.onclose = () => closeDatabase(dbName);\n  return db;\n}\nfunction openDatabase(dbName) {\n  if (!databaseCache[dbName]) {\n    databaseCache[dbName] = createDatabase(dbName);\n  }\n  return databaseCache[dbName];\n}\nfunction dbPromise(db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    // Use relaxed durability because neither the emoji data nor the favorites/preferred skin tone\n    // are really irreplaceable data. IndexedDB is just a cache in this case.\n    const txn = db.transaction(storeName, readOnlyOrReadWrite, {\n      durability: 'relaxed'\n    });\n    const store = typeof storeName === 'string' ? txn.objectStore(storeName) : storeName.map(name => txn.objectStore(name));\n    let res;\n    cb(store, txn, result => {\n      res = result;\n    });\n    txn.oncomplete = () => resolve(res);\n    /* istanbul ignore next */\n    txn.onerror = () => reject(txn.error);\n  });\n}\nfunction closeDatabase(dbName) {\n  // close any open requests\n  const req = openReqs[dbName];\n  const db = req && req.result;\n  if (db) {\n    db.close();\n    const listeners = onCloseListeners[dbName];\n    /* istanbul ignore else */\n    if (listeners) {\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  }\n  delete openReqs[dbName];\n  delete databaseCache[dbName];\n  delete onCloseListeners[dbName];\n}\nfunction deleteDatabase(dbName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    closeDatabase(dbName);\n    const req = indexedDB.deleteDatabase(dbName);\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n}\n\n// The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\nfunction addOnCloseListener(dbName, listener) {\n  let listeners = onCloseListeners[dbName];\n  if (!listeners) {\n    listeners = onCloseListeners[dbName] = [];\n  }\n  listeners.push(listener);\n}\n\n// list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emoji-picker-element-data/en/emojibase/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\nconst irregularEmoticons = new Set([':D', 'XD', \":'D\", 'O:)', ':X', ':P', ';P', 'XP', ':L', ':Z', ':j', '8D', 'XO', '8)', ':B', ':O', ':S', \":'o\", 'Dx', 'X(', 'D:', ':C', '>0)', ':3', '</3', '<3', '\\\\M/', ':E', '8#']);\nfunction extractTokens(str) {\n  return str.split(/[\\s_]+/).map(word => {\n    if (!word.match(/\\w/) || irregularEmoticons.has(word)) {\n      // for pure emoticons like :) or :-), just leave them as-is\n      return word.toLowerCase();\n    }\n    return word.replace(/[)(:,]/g, '').replace(/â€™/g, \"'\").toLowerCase();\n  }).filter(Boolean);\n}\nconst MIN_SEARCH_TEXT_LENGTH = 2;\n\n// This is an extra step in addition to extractTokens(). The difference here is that we expect\n// the input to have already been run through extractTokens(). This is useful for cases like\n// emoticons, where we don't want to do any tokenization (because it makes no sense to split up\n// \">:)\" by the colon) but we do want to lowercase it to have consistent search results, so that\n// the user can type ':P' or ':p' and still get the same result.\nfunction normalizeTokens(str) {\n  return str.filter(Boolean).map(_ => _.toLowerCase()).filter(_ => _.length >= MIN_SEARCH_TEXT_LENGTH);\n}\n\n// Transform emoji data for storage in IDB\nfunction transformEmojiData(emojiData) {\n  const res = emojiData.map(_ref => {\n    let {\n      annotation,\n      emoticon,\n      group,\n      order,\n      shortcodes,\n      skins,\n      tags,\n      emoji,\n      version\n    } = _ref;\n    const tokens = [...new Set(normalizeTokens([...(shortcodes || []).map(extractTokens).flat(), ...tags.map(extractTokens).flat(), ...extractTokens(annotation), emoticon]))].sort();\n    const res = {\n      annotation,\n      group,\n      order,\n      tags,\n      tokens,\n      unicode: emoji,\n      version\n    };\n    if (emoticon) {\n      res.emoticon = emoticon;\n    }\n    if (shortcodes) {\n      res.shortcodes = shortcodes;\n    }\n    if (skins) {\n      res.skinTones = [];\n      res.skinUnicodes = [];\n      res.skinVersions = [];\n      for (const {\n        tone,\n        emoji,\n        version\n      } of skins) {\n        res.skinTones.push(tone);\n        res.skinUnicodes.push(emoji);\n        res.skinVersions.push(version);\n      }\n    }\n    return res;\n  });\n  return res;\n}\n\n// helper functions that help compress the code better\n\nfunction callStore(store, method, key, cb) {\n  store[method](key).onsuccess = e => cb && cb(e.target.result);\n}\nfunction getIDB(store, key, cb) {\n  callStore(store, 'get', key, cb);\n}\nfunction getAllIDB(store, key, cb) {\n  callStore(store, 'getAll', key, cb);\n}\nfunction commit(txn) {\n  /* istanbul ignore else */\n  if (txn.commit) {\n    txn.commit();\n  }\n}\n\n// like lodash's minBy\nfunction minBy(array, func) {\n  let minItem = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (func(minItem) > func(item)) {\n      minItem = item;\n    }\n  }\n  return minItem;\n}\n\n// return an array of results representing all items that are found in each one of the arrays\n\nfunction findCommonMembers(arrays, uniqByFunc) {\n  const shortestArray = minBy(arrays, _ => _.length);\n  const results = [];\n  for (const item of shortestArray) {\n    // if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some(array => array.findIndex(_ => uniqByFunc(_) === uniqByFunc(item)) === -1)) {\n      results.push(item);\n    }\n  }\n  return results;\n}\nasync function isEmpty(db) {\n  return !(await get(db, STORE_KEYVALUE, KEY_URL));\n}\nasync function hasData(db, url, eTag) {\n  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL].map(key => get(db, STORE_KEYVALUE, key)));\n  return oldETag === eTag && oldUrl === url;\n}\nasync function doFullDatabaseScanForSingleResult(db, predicate) {\n  // This batching algorithm is just a perf improvement over a basic\n  // cursor. The BATCH_SIZE is an estimate of what would give the best\n  // perf for doing a full DB scan (worst case).\n  //\n  // Mini-benchmark for determining the best batch size:\n  //\n  // PERF=1 yarn build:rollup && yarn test:adhoc\n  //\n  // (async () => {\n  //   performance.mark('start')\n  //   await $('emoji-picker').database.getEmojiByShortcode('doesnotexist')\n  //   performance.measure('total', 'start')\n  //   console.log(performance.getEntriesByName('total').slice(-1)[0].duration)\n  // })()\n  const BATCH_SIZE = 50; // Typically around 150ms for 6x slowdown in Chrome for above benchmark\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    let lastKey;\n    const processNextBatch = () => {\n      emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = e => {\n        const results = e.target.result;\n        for (const result of results) {\n          lastKey = result.unicode;\n          if (predicate(result)) {\n            return cb(result);\n          }\n        }\n        if (results.length < BATCH_SIZE) {\n          return cb();\n        }\n        processNextBatch();\n      };\n    };\n    processNextBatch();\n  });\n}\nasync function loadData(db, emojiData, url, eTag) {\n  try {\n    const transformedData = transformEmojiData(emojiData);\n    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, (_ref2, txn) => {\n      let [emojiStore, metaStore] = _ref2;\n      let oldETag;\n      let oldUrl;\n      let todo = 0;\n      function checkFetched() {\n        if (++todo === 2) {\n          // 2 requests made\n          onFetched();\n        }\n      }\n      function onFetched() {\n        if (oldETag === eTag && oldUrl === url) {\n          // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n          return;\n        }\n        // delete old data\n        emojiStore.clear();\n        // insert new data\n        for (const data of transformedData) {\n          emojiStore.put(data);\n        }\n        metaStore.put(eTag, KEY_ETAG);\n        metaStore.put(url, KEY_URL);\n        commit(txn);\n      }\n      getIDB(metaStore, KEY_ETAG, result => {\n        oldETag = result;\n        checkFetched();\n      });\n      getIDB(metaStore, KEY_URL, result => {\n        oldUrl = result;\n        checkFetched();\n      });\n    });\n  } finally {}\n}\nasync function getEmojiByGroup(db, group) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);\n    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);\n  });\n}\nasync function getEmojiBySearchQuery(db, query) {\n  const tokens = normalizeTokens(extractTokens(query));\n  if (!tokens.length) {\n    return [];\n  }\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    // get all results that contain all tokens (i.e. an AND query)\n    const intermediateResults = [];\n    const checkDone = () => {\n      if (intermediateResults.length === tokens.length) {\n        onDone();\n      }\n    };\n    const onDone = () => {\n      const results = findCommonMembers(intermediateResults, _ => _.unicode);\n      cb(results.sort((a, b) => a.order < b.order ? -1 : 1));\n    };\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const range = i === tokens.length - 1 ? IDBKeyRange.bound(token, token + '\\uffff', false, true) // treat last token as a prefix search\n      : IDBKeyRange.only(token); // treat all other tokens as an exact match\n      getAllIDB(emojiStore.index(INDEX_TOKENS), range, result => {\n        intermediateResults.push(result);\n        checkDone();\n      });\n    }\n  });\n}\n\n// This could have been implemented as an IDB index on shortcodes, but it seemed wasteful to do that\n// when we can already query by tokens and this will give us what we're looking for 99.9% of the time\nasync function getEmojiByShortcode(db, shortcode) {\n  const emojis = await getEmojiBySearchQuery(db, shortcode);\n\n  // In very rare cases (e.g. the shortcode \"v\" as in \"v for victory\"), we cannot search because\n  // there are no usable tokens (too short in this case). In that case, we have to do an inefficient\n  // full-database scan, which I believe is an acceptable tradeoff for not having to have an extra\n  // index on shortcodes.\n\n  if (!emojis.length) {\n    const predicate = _ => (_.shortcodes || []).includes(shortcode.toLowerCase());\n    return (await doFullDatabaseScanForSingleResult(db, predicate)) || null;\n  }\n  return emojis.filter(_ => {\n    const lowerShortcodes = (_.shortcodes || []).map(_ => _.toLowerCase());\n    return lowerShortcodes.includes(shortcode.toLowerCase());\n  })[0] || null;\n}\nasync function getEmojiByUnicode(db, unicode) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => getIDB(emojiStore, unicode, result => {\n    if (result) {\n      return cb(result);\n    }\n    getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, result => cb(result || null));\n  }));\n}\nfunction get(db, storeName, key) {\n  return dbPromise(db, storeName, MODE_READONLY, (store, txn, cb) => getIDB(store, key, cb));\n}\nfunction set(db, storeName, key, value) {\n  return dbPromise(db, storeName, MODE_READWRITE, (store, txn) => {\n    store.put(value, key);\n    commit(txn);\n  });\n}\nfunction incrementFavoriteEmojiCount(db, unicode) {\n  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store, txn) => getIDB(store, unicode, result => {\n    store.put((result || 0) + 1, unicode);\n    commit(txn);\n  }));\n}\nfunction getTopFavoriteEmoji(db, customEmojiIndex, limit) {\n  if (limit === 0) {\n    return [];\n  }\n  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, (_ref3, txn, cb) => {\n    let [favoritesStore, emojiStore] = _ref3;\n    const results = [];\n    favoritesStore.index(INDEX_COUNT).openCursor(undefined, 'prev').onsuccess = e => {\n      const cursor = e.target.result;\n      if (!cursor) {\n        // no more results\n        return cb(results);\n      }\n      function addResult(result) {\n        results.push(result);\n        if (results.length === limit) {\n          return cb(results); // done, reached the limit\n        }\n\n        cursor.continue();\n      }\n      const unicodeOrName = cursor.primaryKey;\n      const custom = customEmojiIndex.byName(unicodeOrName);\n      if (custom) {\n        return addResult(custom);\n      }\n      // This could be done in parallel (i.e. make the cursor and the get()s parallelized),\n      // but my testing suggests it's not actually faster.\n      getIDB(emojiStore, unicodeOrName, emoji => {\n        if (emoji) {\n          return addResult(emoji);\n        }\n        // emoji not found somehow, ignore (may happen if custom emoji change)\n        cursor.continue();\n      });\n    };\n  });\n}\n\n// trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\n\nconst CODA_MARKER = ''; // marks the end of the string\n\nfunction trie(arr, itemToTokens) {\n  const map = new Map();\n  for (const item of arr) {\n    const tokens = itemToTokens(item);\n    for (const token of tokens) {\n      let currentMap = map;\n      for (let i = 0; i < token.length; i++) {\n        const char = token.charAt(i);\n        let nextMap = currentMap.get(char);\n        if (!nextMap) {\n          nextMap = new Map();\n          currentMap.set(char, nextMap);\n        }\n        currentMap = nextMap;\n      }\n      let valuesAtCoda = currentMap.get(CODA_MARKER);\n      if (!valuesAtCoda) {\n        valuesAtCoda = [];\n        currentMap.set(CODA_MARKER, valuesAtCoda);\n      }\n      valuesAtCoda.push(item);\n    }\n  }\n  const search = (query, exact) => {\n    let currentMap = map;\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charAt(i);\n      const nextMap = currentMap.get(char);\n      if (nextMap) {\n        currentMap = nextMap;\n      } else {\n        return [];\n      }\n    }\n    if (exact) {\n      const results = currentMap.get(CODA_MARKER);\n      return results || [];\n    }\n    const results = [];\n    // traverse\n    const queue = [currentMap];\n    while (queue.length) {\n      const currentMap = queue.shift();\n      const entriesSortedByKey = [...currentMap.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);\n      for (const [key, value] of entriesSortedByKey) {\n        if (key === CODA_MARKER) {\n          // CODA_MARKER always comes first; it's the empty string\n          results.push(...value);\n        } else {\n          queue.push(value);\n        }\n      }\n    }\n    return results;\n  };\n  return search;\n}\nconst requiredKeys$1 = ['name', 'url'];\nfunction assertCustomEmojis(customEmojis) {\n  const isArray = customEmojis && Array.isArray(customEmojis);\n  const firstItemIsFaulty = isArray && customEmojis.length && (!customEmojis[0] || requiredKeys$1.some(key => !(key in customEmojis[0])));\n  if (!isArray || firstItemIsFaulty) {\n    throw new Error('Custom emojis are in the wrong format');\n  }\n}\nfunction customEmojiIndex(customEmojis) {\n  assertCustomEmojis(customEmojis);\n  const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;\n\n  //\n  // all()\n  //\n  const all = customEmojis.sort(sortByName);\n\n  //\n  // search()\n  //\n  const emojiToTokens = emoji => [...new Set((emoji.shortcodes || []).map(shortcode => extractTokens(shortcode)).flat())];\n  const searchTrie = trie(customEmojis, emojiToTokens);\n  const searchByExactMatch = _ => searchTrie(_, true);\n  const searchByPrefix = _ => searchTrie(_, false);\n\n  // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n  // is treated as a prefix search, but every other one is treated as an exact match.\n  // Then we AND the results together\n  const search = query => {\n    const tokens = extractTokens(query);\n    const intermediateResults = tokens.map((token, i) => (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token));\n    return findCommonMembers(intermediateResults, _ => _.name).sort(sortByName);\n  };\n\n  //\n  // byShortcode, byName\n  //\n  const shortcodeToEmoji = new Map();\n  const nameToEmoji = new Map();\n  for (const customEmoji of customEmojis) {\n    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n    for (const shortcode of customEmoji.shortcodes || []) {\n      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n  }\n  const byShortcode = shortcode => shortcodeToEmoji.get(shortcode.toLowerCase());\n  const byName = name => nameToEmoji.get(name.toLowerCase());\n  return {\n    all,\n    search,\n    byShortcode,\n    byName\n  };\n}\n\n// remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\nfunction cleanEmoji(emoji) {\n  if (!emoji) {\n    return emoji;\n  }\n  delete emoji.tokens;\n  if (emoji.skinTones) {\n    const len = emoji.skinTones.length;\n    emoji.skins = Array(len);\n    for (let i = 0; i < len; i++) {\n      emoji.skins[i] = {\n        tone: emoji.skinTones[i],\n        unicode: emoji.skinUnicodes[i],\n        version: emoji.skinVersions[i]\n      };\n    }\n    delete emoji.skinTones;\n    delete emoji.skinUnicodes;\n    delete emoji.skinVersions;\n  }\n  return emoji;\n}\nfunction warnETag(eTag) {\n  if (!eTag) {\n    console.warn('emoji-picker-element is more efficient if the dataSource server exposes an ETag header.');\n  }\n}\nconst requiredKeys = ['annotation', 'emoji', 'group', 'order', 'tags', 'version'];\nfunction assertEmojiData(emojiData) {\n  if (!emojiData || !Array.isArray(emojiData) || !emojiData[0] || typeof emojiData[0] !== 'object' || requiredKeys.some(key => !(key in emojiData[0]))) {\n    throw new Error('Emoji data is in the wrong format');\n  }\n}\nfunction assertStatus(response, dataSource) {\n  if (Math.floor(response.status / 100) !== 2) {\n    throw new Error('Failed to fetch: ' + dataSource + ':  ' + response.status);\n  }\n}\nasync function getETag(dataSource) {\n  const response = await fetch(dataSource, {\n    method: 'HEAD'\n  });\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  return eTag;\n}\nasync function getETagAndData(dataSource) {\n  const response = await fetch(dataSource);\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  const emojiData = await response.json();\n  assertEmojiData(emojiData);\n  return [eTag, emojiData];\n}\n\n// TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n/**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  var i = -1;\n  while (++i < length) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */\nfunction binaryStringToArrayBuffer(binary) {\n  var length = binary.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  var i = -1;\n  while (++i < length) {\n    arr[i] = binary.charCodeAt(i);\n  }\n  return buf;\n}\n\n// generate a checksum based on the stringified JSON\nasync function jsonChecksum(object) {\n  const inString = JSON.stringify(object);\n  const inBuffer = binaryStringToArrayBuffer(inString);\n  // this does not need to be cryptographically secure, SHA-1 is fine\n  const outBuffer = await crypto.subtle.digest('SHA-1', inBuffer);\n  const outBinString = arrayBufferToBinaryString(outBuffer);\n  const res = btoa(outBinString);\n  return res;\n}\nasync function checkForUpdates(db, dataSource) {\n  // just do a simple HEAD request first to see if the eTags match\n  let emojiData;\n  let eTag = await getETag(dataSource);\n  if (!eTag) {\n    // work around lack of ETag/Access-Control-Expose-Headers\n    const eTagAndData = await getETagAndData(dataSource);\n    eTag = eTagAndData[0];\n    emojiData = eTagAndData[1];\n    if (!eTag) {\n      eTag = await jsonChecksum(emojiData);\n    }\n  }\n  if (await hasData(db, dataSource, eTag)) ;else {\n    if (!emojiData) {\n      const eTagAndData = await getETagAndData(dataSource);\n      emojiData = eTagAndData[1];\n    }\n    await loadData(db, emojiData, dataSource, eTag);\n  }\n}\nasync function loadDataForFirstTime(db, dataSource) {\n  let [eTag, emojiData] = await getETagAndData(dataSource);\n  if (!eTag) {\n    // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await jsonChecksum(emojiData);\n  }\n  await loadData(db, emojiData, dataSource, eTag);\n}\nclass Database {\n  constructor() {\n    let {\n      dataSource = DEFAULT_DATA_SOURCE,\n      locale = DEFAULT_LOCALE,\n      customEmoji = []\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.dataSource = dataSource;\n    this.locale = locale;\n    this._dbName = `emoji-picker-element-${this.locale}`;\n    this._db = undefined;\n    this._lazyUpdate = undefined;\n    this._custom = customEmojiIndex(customEmoji);\n    this._clear = this._clear.bind(this);\n    this._ready = this._init();\n  }\n  async _init() {\n    const db = this._db = await openDatabase(this._dbName);\n    addOnCloseListener(this._dbName, this._clear);\n    const dataSource = this.dataSource;\n    const empty = await isEmpty(db);\n    if (empty) {\n      await loadDataForFirstTime(db, dataSource);\n    } else {\n      // offline-first - do an update asynchronously\n      this._lazyUpdate = checkForUpdates(db, dataSource);\n    }\n  }\n  async ready() {\n    const checkReady = async () => {\n      if (!this._ready) {\n        this._ready = this._init();\n      }\n      return this._ready;\n    };\n    await checkReady();\n    // There's a possibility of a race condition where the element gets added, removed, and then added again\n    // with a particular timing, which would set the _db to undefined.\n    // We *could* do a while loop here, but that seems excessive and could lead to an infinite loop.\n    if (!this._db) {\n      await checkReady();\n    }\n  }\n  async getEmojiByGroup(group) {\n    assertNumber(group);\n    await this.ready();\n    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji);\n  }\n  async getEmojiBySearchQuery(query) {\n    assertNonEmptyString(query);\n    await this.ready();\n    const customs = this._custom.search(query);\n    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);\n    return [...customs, ...natives];\n  }\n  async getEmojiByShortcode(shortcode) {\n    assertNonEmptyString(shortcode);\n    await this.ready();\n    const custom = this._custom.byShortcode(shortcode);\n    if (custom) {\n      return custom;\n    }\n    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode));\n  }\n  async getEmojiByUnicodeOrName(unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    const custom = this._custom.byName(unicodeOrName);\n    if (custom) {\n      return custom;\n    }\n    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName));\n  }\n  async getPreferredSkinTone() {\n    await this.ready();\n    return (await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE)) || 0;\n  }\n  async setPreferredSkinTone(skinTone) {\n    assertNumber(skinTone);\n    await this.ready();\n    return set(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone);\n  }\n  async incrementFavoriteEmojiCount(unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    return incrementFavoriteEmojiCount(this._db, unicodeOrName);\n  }\n  async getTopFavoriteEmoji(limit) {\n    assertNumber(limit);\n    await this.ready();\n    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji);\n  }\n  set customEmoji(customEmojis) {\n    this._custom = customEmojiIndex(customEmojis);\n  }\n  get customEmoji() {\n    return this._custom.all;\n  }\n  async _shutdown() {\n    await this.ready(); // reopen if we've already been closed/deleted\n    try {\n      await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n    } catch (err) {/* ignore network errors (offline-first) */}\n  }\n\n  // clear references to IDB, e.g. during a close event\n  _clear() {\n    // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n    // The memory leak tests prove this is unnecessary. It's because:\n    // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n    // 2) we clear the manual close listeners in databaseLifecycle.js.\n    this._db = this._ready = this._lazyUpdate = undefined;\n  }\n  async close() {\n    await this._shutdown();\n    await closeDatabase(this._dbName);\n  }\n  async delete() {\n    await this._shutdown();\n    await deleteDatabase(this._dbName);\n  }\n}\nexport { Database as default };","map":{"version":3,"names":["assertNonEmptyString","str","Error","assertNumber","number","DB_VERSION_CURRENT","DB_VERSION_INITIAL","STORE_EMOJI","STORE_KEYVALUE","STORE_FAVORITES","FIELD_TOKENS","INDEX_TOKENS","FIELD_UNICODE","INDEX_COUNT","FIELD_GROUP","FIELD_ORDER","INDEX_GROUP_AND_ORDER","KEY_ETAG","KEY_URL","KEY_PREFERRED_SKINTONE","MODE_READONLY","MODE_READWRITE","INDEX_SKIN_UNICODE","FIELD_SKIN_UNICODE","DEFAULT_DATA_SOURCE","DEFAULT_LOCALE","uniqBy","arr","func","set","Set","res","item","key","has","add","push","uniqEmoji","emojis","_","unicode","initialMigration","db","createObjectStore","name","keyPath","indexes","store","indexName","multiEntry","Object","entries","createIndex","undefined","openReqs","databaseCache","onCloseListeners","handleOpenOrDeleteReq","resolve","reject","req","onerror","error","onblocked","onsuccess","result","createDatabase","dbName","Promise","indexedDB","open","onupgradeneeded","e","oldVersion","onclose","closeDatabase","openDatabase","dbPromise","storeName","readOnlyOrReadWrite","cb","txn","transaction","durability","objectStore","map","oncomplete","close","listeners","listener","deleteDatabase","addOnCloseListener","irregularEmoticons","extractTokens","split","word","match","toLowerCase","replace","filter","Boolean","MIN_SEARCH_TEXT_LENGTH","normalizeTokens","length","transformEmojiData","emojiData","annotation","emoticon","group","order","shortcodes","skins","tags","emoji","version","tokens","flat","sort","skinTones","skinUnicodes","skinVersions","tone","callStore","method","target","getIDB","getAllIDB","commit","minBy","array","minItem","i","findCommonMembers","arrays","uniqByFunc","shortestArray","results","some","findIndex","isEmpty","get","hasData","url","eTag","oldETag","oldUrl","all","doFullDatabaseScanForSingleResult","predicate","BATCH_SIZE","emojiStore","lastKey","processNextBatch","getAll","IDBKeyRange","lowerBound","loadData","transformedData","metaStore","todo","checkFetched","onFetched","clear","data","put","getEmojiByGroup","range","bound","index","getEmojiBySearchQuery","query","intermediateResults","checkDone","onDone","a","b","token","only","getEmojiByShortcode","shortcode","includes","lowerShortcodes","getEmojiByUnicode","value","incrementFavoriteEmojiCount","getTopFavoriteEmoji","customEmojiIndex","limit","favoritesStore","openCursor","cursor","addResult","continue","unicodeOrName","primaryKey","custom","byName","CODA_MARKER","trie","itemToTokens","Map","currentMap","char","charAt","nextMap","valuesAtCoda","search","exact","queue","shift","entriesSortedByKey","requiredKeys$1","assertCustomEmojis","customEmojis","isArray","Array","firstItemIsFaulty","sortByName","emojiToTokens","searchTrie","searchByExactMatch","searchByPrefix","shortcodeToEmoji","nameToEmoji","customEmoji","byShortcode","cleanEmoji","len","warnETag","console","warn","requiredKeys","assertEmojiData","assertStatus","response","dataSource","Math","floor","status","getETag","fetch","headers","getETagAndData","json","arrayBufferToBinaryString","buffer","binary","bytes","Uint8Array","byteLength","String","fromCharCode","binaryStringToArrayBuffer","buf","ArrayBuffer","charCodeAt","jsonChecksum","object","inString","JSON","stringify","inBuffer","outBuffer","crypto","subtle","digest","outBinString","btoa","checkForUpdates","eTagAndData","loadDataForFirstTime","Database","constructor","locale","_dbName","_db","_lazyUpdate","_custom","_clear","bind","_ready","_init","empty","ready","checkReady","customs","natives","getEmojiByUnicodeOrName","getPreferredSkinTone","setPreferredSkinTone","skinTone","_shutdown","err","delete","default"],"sources":["C:/Users/samth/repomain-1/node_modules/emoji-picker-element/database.js"],"sourcesContent":["function assertNonEmptyString (str) {\n  if (typeof str !== 'string' || !str) {\n    throw new Error('expected a non-empty string, got: ' + str)\n  }\n}\n\nfunction assertNumber (number) {\n  if (typeof number !== 'number') {\n    throw new Error('expected a number, got: ' + number)\n  }\n}\n\nconst DB_VERSION_CURRENT = 1;\nconst DB_VERSION_INITIAL = 1;\nconst STORE_EMOJI = 'emoji';\nconst STORE_KEYVALUE = 'keyvalue';\nconst STORE_FAVORITES = 'favorites';\nconst FIELD_TOKENS = 'tokens';\nconst INDEX_TOKENS = 'tokens';\nconst FIELD_UNICODE = 'unicode';\nconst INDEX_COUNT = 'count';\nconst FIELD_GROUP = 'group';\nconst FIELD_ORDER = 'order';\nconst INDEX_GROUP_AND_ORDER = 'group-order';\nconst KEY_ETAG = 'eTag';\nconst KEY_URL = 'url';\nconst KEY_PREFERRED_SKINTONE = 'skinTone';\nconst MODE_READONLY = 'readonly';\nconst MODE_READWRITE = 'readwrite';\nconst INDEX_SKIN_UNICODE = 'skinUnicodes';\nconst FIELD_SKIN_UNICODE = 'skinUnicodes';\n\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json';\nconst DEFAULT_LOCALE = 'en';\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy (arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res\n}\n\nfunction uniqEmoji (emojis) {\n  return uniqBy(emojis, _ => _.unicode)\n}\n\nfunction initialMigration (db) {\n  function createObjectStore (name, keyPath, indexes) {\n    const store = keyPath\n      ? db.createObjectStore(name, { keyPath })\n      : db.createObjectStore(name);\n    if (indexes) {\n      for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes)) {\n        store.createIndex(indexName, keyPath, { multiEntry });\n      }\n    }\n    return store\n  }\n\n  createObjectStore(STORE_KEYVALUE);\n  createObjectStore(STORE_EMOJI, /* keyPath */ FIELD_UNICODE, {\n    [INDEX_TOKENS]: [FIELD_TOKENS, /* multiEntry */ true],\n    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],\n    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, /* multiEntry */ true]\n  });\n  createObjectStore(STORE_FAVORITES, undefined, {\n    [INDEX_COUNT]: ['']\n  });\n}\n\nconst openReqs = {};\nconst databaseCache = {};\nconst onCloseListeners = {};\n\nfunction handleOpenOrDeleteReq (resolve, reject, req) {\n  // These things are almost impossible to test with fakeIndexedDB sadly\n  /* istanbul ignore next */\n  req.onerror = () => reject(req.error);\n  /* istanbul ignore next */\n  req.onblocked = () => reject(new Error('IDB blocked'));\n  req.onsuccess = () => resolve(req.result);\n}\n\nasync function createDatabase (dbName) {\n  const db = await new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);\n    openReqs[dbName] = req;\n    req.onupgradeneeded = e => {\n      // Technically there is only one version, so we don't need this `if` check\n      // But if an old version of the JS is in another browser tab\n      // and it gets upgraded in the future and we have a new DB version, well...\n      // better safe than sorry.\n      /* istanbul ignore else */\n      if (e.oldVersion < DB_VERSION_INITIAL) {\n        initialMigration(req.result);\n      }\n    };\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n  // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n  // No need for removeEventListener, because once the DB can no longer\n  // fire \"close\" events, it will auto-GC.\n  // Unfortunately cannot test in fakeIndexedDB: https://github.com/dumbmatter/fakeIndexedDB/issues/50\n  /* istanbul ignore next */\n  db.onclose = () => closeDatabase(dbName);\n  return db\n}\n\nfunction openDatabase (dbName) {\n  if (!databaseCache[dbName]) {\n    databaseCache[dbName] = createDatabase(dbName);\n  }\n  return databaseCache[dbName]\n}\n\nfunction dbPromise (db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    // Use relaxed durability because neither the emoji data nor the favorites/preferred skin tone\n    // are really irreplaceable data. IndexedDB is just a cache in this case.\n    const txn = db.transaction(storeName, readOnlyOrReadWrite, { durability: 'relaxed' });\n    const store = typeof storeName === 'string'\n      ? txn.objectStore(storeName)\n      : storeName.map(name => txn.objectStore(name));\n    let res;\n    cb(store, txn, (result) => {\n      res = result;\n    });\n\n    txn.oncomplete = () => resolve(res);\n    /* istanbul ignore next */\n    txn.onerror = () => reject(txn.error);\n  })\n}\n\nfunction closeDatabase (dbName) {\n  // close any open requests\n  const req = openReqs[dbName];\n  const db = req && req.result;\n  if (db) {\n    db.close();\n    const listeners = onCloseListeners[dbName];\n    /* istanbul ignore else */\n    if (listeners) {\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  }\n  delete openReqs[dbName];\n  delete databaseCache[dbName];\n  delete onCloseListeners[dbName];\n}\n\nfunction deleteDatabase (dbName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    closeDatabase(dbName);\n    const req = indexedDB.deleteDatabase(dbName);\n    handleOpenOrDeleteReq(resolve, reject, req);\n  })\n}\n\n// The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\nfunction addOnCloseListener (dbName, listener) {\n  let listeners = onCloseListeners[dbName];\n  if (!listeners) {\n    listeners = onCloseListeners[dbName] = [];\n  }\n  listeners.push(listener);\n}\n\n// list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emoji-picker-element-data/en/emojibase/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\nconst irregularEmoticons = new Set([\n  ':D', 'XD', \":'D\", 'O:)',\n  ':X', ':P', ';P', 'XP',\n  ':L', ':Z', ':j', '8D',\n  'XO', '8)', ':B', ':O',\n  ':S', \":'o\", 'Dx', 'X(',\n  'D:', ':C', '>0)', ':3',\n  '</3', '<3', '\\\\M/', ':E',\n  '8#'\n]);\n\nfunction extractTokens (str) {\n  return str\n    .split(/[\\s_]+/)\n    .map(word => {\n      if (!word.match(/\\w/) || irregularEmoticons.has(word)) {\n        // for pure emoticons like :) or :-), just leave them as-is\n        return word.toLowerCase()\n      }\n\n      return word\n        .replace(/[)(:,]/g, '')\n        .replace(/â€™/g, \"'\")\n        .toLowerCase()\n    }).filter(Boolean)\n}\n\nconst MIN_SEARCH_TEXT_LENGTH = 2;\n\n// This is an extra step in addition to extractTokens(). The difference here is that we expect\n// the input to have already been run through extractTokens(). This is useful for cases like\n// emoticons, where we don't want to do any tokenization (because it makes no sense to split up\n// \">:)\" by the colon) but we do want to lowercase it to have consistent search results, so that\n// the user can type ':P' or ':p' and still get the same result.\nfunction normalizeTokens (str) {\n  return str\n    .filter(Boolean)\n    .map(_ => _.toLowerCase())\n    .filter(_ => _.length >= MIN_SEARCH_TEXT_LENGTH)\n}\n\n// Transform emoji data for storage in IDB\nfunction transformEmojiData (emojiData) {\n  const res = emojiData.map(({ annotation, emoticon, group, order, shortcodes, skins, tags, emoji, version }) => {\n    const tokens = [...new Set(\n      normalizeTokens([\n        ...(shortcodes || []).map(extractTokens).flat(),\n        ...tags.map(extractTokens).flat(),\n        ...extractTokens(annotation),\n        emoticon\n      ])\n    )].sort();\n    const res = {\n      annotation,\n      group,\n      order,\n      tags,\n      tokens,\n      unicode: emoji,\n      version\n    };\n    if (emoticon) {\n      res.emoticon = emoticon;\n    }\n    if (shortcodes) {\n      res.shortcodes = shortcodes;\n    }\n    if (skins) {\n      res.skinTones = [];\n      res.skinUnicodes = [];\n      res.skinVersions = [];\n      for (const { tone, emoji, version } of skins) {\n        res.skinTones.push(tone);\n        res.skinUnicodes.push(emoji);\n        res.skinVersions.push(version);\n      }\n    }\n    return res\n  });\n  return res\n}\n\n// helper functions that help compress the code better\n\nfunction callStore (store, method, key, cb) {\n  store[method](key).onsuccess = e => (cb && cb(e.target.result));\n}\n\nfunction getIDB (store, key, cb) {\n  callStore(store, 'get', key, cb);\n}\n\nfunction getAllIDB (store, key, cb) {\n  callStore(store, 'getAll', key, cb);\n}\n\nfunction commit (txn) {\n  /* istanbul ignore else */\n  if (txn.commit) {\n    txn.commit();\n  }\n}\n\n// like lodash's minBy\nfunction minBy (array, func) {\n  let minItem = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (func(minItem) > func(item)) {\n      minItem = item;\n    }\n  }\n  return minItem\n}\n\n// return an array of results representing all items that are found in each one of the arrays\n\nfunction findCommonMembers (arrays, uniqByFunc) {\n  const shortestArray = minBy(arrays, _ => _.length);\n  const results = [];\n  for (const item of shortestArray) {\n    // if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some(array => array.findIndex(_ => uniqByFunc(_) === uniqByFunc(item)) === -1)) {\n      results.push(item);\n    }\n  }\n  return results\n}\n\nasync function isEmpty (db) {\n  return !(await get(db, STORE_KEYVALUE, KEY_URL))\n}\n\nasync function hasData (db, url, eTag) {\n  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL]\n    .map(key => get(db, STORE_KEYVALUE, key)));\n  return (oldETag === eTag && oldUrl === url)\n}\n\nasync function doFullDatabaseScanForSingleResult (db, predicate) {\n  // This batching algorithm is just a perf improvement over a basic\n  // cursor. The BATCH_SIZE is an estimate of what would give the best\n  // perf for doing a full DB scan (worst case).\n  //\n  // Mini-benchmark for determining the best batch size:\n  //\n  // PERF=1 yarn build:rollup && yarn test:adhoc\n  //\n  // (async () => {\n  //   performance.mark('start')\n  //   await $('emoji-picker').database.getEmojiByShortcode('doesnotexist')\n  //   performance.measure('total', 'start')\n  //   console.log(performance.getEntriesByName('total').slice(-1)[0].duration)\n  // })()\n  const BATCH_SIZE = 50; // Typically around 150ms for 6x slowdown in Chrome for above benchmark\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    let lastKey;\n\n    const processNextBatch = () => {\n      emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = e => {\n        const results = e.target.result;\n        for (const result of results) {\n          lastKey = result.unicode;\n          if (predicate(result)) {\n            return cb(result)\n          }\n        }\n        if (results.length < BATCH_SIZE) {\n          return cb()\n        }\n        processNextBatch();\n      };\n    };\n    processNextBatch();\n  })\n}\n\nasync function loadData (db, emojiData, url, eTag) {\n  try {\n    const transformedData = transformEmojiData(emojiData);\n    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, ([emojiStore, metaStore], txn) => {\n      let oldETag;\n      let oldUrl;\n      let todo = 0;\n\n      function checkFetched () {\n        if (++todo === 2) { // 2 requests made\n          onFetched();\n        }\n      }\n\n      function onFetched () {\n        if (oldETag === eTag && oldUrl === url) {\n          // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n          return\n        }\n        // delete old data\n        emojiStore.clear();\n        // insert new data\n        for (const data of transformedData) {\n          emojiStore.put(data);\n        }\n        metaStore.put(eTag, KEY_ETAG);\n        metaStore.put(url, KEY_URL);\n        commit(txn);\n      }\n\n      getIDB(metaStore, KEY_ETAG, result => {\n        oldETag = result;\n        checkFetched();\n      });\n\n      getIDB(metaStore, KEY_URL, result => {\n        oldUrl = result;\n        checkFetched();\n      });\n    });\n  } finally {\n  }\n}\n\nasync function getEmojiByGroup (db, group) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);\n    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);\n  })\n}\n\nasync function getEmojiBySearchQuery (db, query) {\n  const tokens = normalizeTokens(extractTokens(query));\n\n  if (!tokens.length) {\n    return []\n  }\n\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    // get all results that contain all tokens (i.e. an AND query)\n    const intermediateResults = [];\n\n    const checkDone = () => {\n      if (intermediateResults.length === tokens.length) {\n        onDone();\n      }\n    };\n\n    const onDone = () => {\n      const results = findCommonMembers(intermediateResults, _ => _.unicode);\n      cb(results.sort((a, b) => a.order < b.order ? -1 : 1));\n    };\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const range = i === tokens.length - 1\n        ? IDBKeyRange.bound(token, token + '\\uffff', false, true) // treat last token as a prefix search\n        : IDBKeyRange.only(token); // treat all other tokens as an exact match\n      getAllIDB(emojiStore.index(INDEX_TOKENS), range, result => {\n        intermediateResults.push(result);\n        checkDone();\n      });\n    }\n  })\n}\n\n// This could have been implemented as an IDB index on shortcodes, but it seemed wasteful to do that\n// when we can already query by tokens and this will give us what we're looking for 99.9% of the time\nasync function getEmojiByShortcode (db, shortcode) {\n  const emojis = await getEmojiBySearchQuery(db, shortcode);\n\n  // In very rare cases (e.g. the shortcode \"v\" as in \"v for victory\"), we cannot search because\n  // there are no usable tokens (too short in this case). In that case, we have to do an inefficient\n  // full-database scan, which I believe is an acceptable tradeoff for not having to have an extra\n  // index on shortcodes.\n\n  if (!emojis.length) {\n    const predicate = _ => ((_.shortcodes || []).includes(shortcode.toLowerCase()));\n    return (await doFullDatabaseScanForSingleResult(db, predicate)) || null\n  }\n\n  return emojis.filter(_ => {\n    const lowerShortcodes = (_.shortcodes || []).map(_ => _.toLowerCase());\n    return lowerShortcodes.includes(shortcode.toLowerCase())\n  })[0] || null\n}\n\nasync function getEmojiByUnicode (db, unicode) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => (\n    getIDB(emojiStore, unicode, result => {\n      if (result) {\n        return cb(result)\n      }\n      getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, result => cb(result || null));\n    })\n  ))\n}\n\nfunction get (db, storeName, key) {\n  return dbPromise(db, storeName, MODE_READONLY, (store, txn, cb) => (\n    getIDB(store, key, cb)\n  ))\n}\n\nfunction set (db, storeName, key, value) {\n  return dbPromise(db, storeName, MODE_READWRITE, (store, txn) => {\n    store.put(value, key);\n    commit(txn);\n  })\n}\n\nfunction incrementFavoriteEmojiCount (db, unicode) {\n  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store, txn) => (\n    getIDB(store, unicode, result => {\n      store.put((result || 0) + 1, unicode);\n      commit(txn);\n    })\n  ))\n}\n\nfunction getTopFavoriteEmoji (db, customEmojiIndex, limit) {\n  if (limit === 0) {\n    return []\n  }\n  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, ([favoritesStore, emojiStore], txn, cb) => {\n    const results = [];\n    favoritesStore.index(INDEX_COUNT).openCursor(undefined, 'prev').onsuccess = e => {\n      const cursor = e.target.result;\n      if (!cursor) { // no more results\n        return cb(results)\n      }\n\n      function addResult (result) {\n        results.push(result);\n        if (results.length === limit) {\n          return cb(results) // done, reached the limit\n        }\n        cursor.continue();\n      }\n\n      const unicodeOrName = cursor.primaryKey;\n      const custom = customEmojiIndex.byName(unicodeOrName);\n      if (custom) {\n        return addResult(custom)\n      }\n      // This could be done in parallel (i.e. make the cursor and the get()s parallelized),\n      // but my testing suggests it's not actually faster.\n      getIDB(emojiStore, unicodeOrName, emoji => {\n        if (emoji) {\n          return addResult(emoji)\n        }\n        // emoji not found somehow, ignore (may happen if custom emoji change)\n        cursor.continue();\n      });\n    };\n  })\n}\n\n// trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\n\nconst CODA_MARKER = ''; // marks the end of the string\n\nfunction trie (arr, itemToTokens) {\n  const map = new Map();\n  for (const item of arr) {\n    const tokens = itemToTokens(item);\n    for (const token of tokens) {\n      let currentMap = map;\n      for (let i = 0; i < token.length; i++) {\n        const char = token.charAt(i);\n        let nextMap = currentMap.get(char);\n        if (!nextMap) {\n          nextMap = new Map();\n          currentMap.set(char, nextMap);\n        }\n        currentMap = nextMap;\n      }\n      let valuesAtCoda = currentMap.get(CODA_MARKER);\n      if (!valuesAtCoda) {\n        valuesAtCoda = [];\n        currentMap.set(CODA_MARKER, valuesAtCoda);\n      }\n      valuesAtCoda.push(item);\n    }\n  }\n\n  const search = (query, exact) => {\n    let currentMap = map;\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charAt(i);\n      const nextMap = currentMap.get(char);\n      if (nextMap) {\n        currentMap = nextMap;\n      } else {\n        return []\n      }\n    }\n\n    if (exact) {\n      const results = currentMap.get(CODA_MARKER);\n      return results || []\n    }\n\n    const results = [];\n    // traverse\n    const queue = [currentMap];\n    while (queue.length) {\n      const currentMap = queue.shift();\n      const entriesSortedByKey = [...currentMap.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);\n      for (const [key, value] of entriesSortedByKey) {\n        if (key === CODA_MARKER) { // CODA_MARKER always comes first; it's the empty string\n          results.push(...value);\n        } else {\n          queue.push(value);\n        }\n      }\n    }\n    return results\n  };\n\n  return search\n}\n\nconst requiredKeys$1 = [\n  'name',\n  'url'\n];\n\nfunction assertCustomEmojis (customEmojis) {\n  const isArray = customEmojis && Array.isArray(customEmojis);\n  const firstItemIsFaulty = isArray &&\n    customEmojis.length &&\n    (!customEmojis[0] || requiredKeys$1.some(key => !(key in customEmojis[0])));\n  if (!isArray || firstItemIsFaulty) {\n    throw new Error('Custom emojis are in the wrong format')\n  }\n}\n\nfunction customEmojiIndex (customEmojis) {\n  assertCustomEmojis(customEmojis);\n\n  const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;\n\n  //\n  // all()\n  //\n  const all = customEmojis.sort(sortByName);\n\n  //\n  // search()\n  //\n  const emojiToTokens = emoji => (\n    [...new Set((emoji.shortcodes || []).map(shortcode => extractTokens(shortcode)).flat())]\n  );\n  const searchTrie = trie(customEmojis, emojiToTokens);\n  const searchByExactMatch = _ => searchTrie(_, true);\n  const searchByPrefix = _ => searchTrie(_, false);\n\n  // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n  // is treated as a prefix search, but every other one is treated as an exact match.\n  // Then we AND the results together\n  const search = query => {\n    const tokens = extractTokens(query);\n    const intermediateResults = tokens.map((token, i) => (\n      (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token)\n    ));\n    return findCommonMembers(intermediateResults, _ => _.name).sort(sortByName)\n  };\n\n  //\n  // byShortcode, byName\n  //\n  const shortcodeToEmoji = new Map();\n  const nameToEmoji = new Map();\n  for (const customEmoji of customEmojis) {\n    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n    for (const shortcode of (customEmoji.shortcodes || [])) {\n      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n  }\n\n  const byShortcode = shortcode => shortcodeToEmoji.get(shortcode.toLowerCase());\n  const byName = name => nameToEmoji.get(name.toLowerCase());\n\n  return {\n    all,\n    search,\n    byShortcode,\n    byName\n  }\n}\n\n// remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\nfunction cleanEmoji (emoji) {\n  if (!emoji) {\n    return emoji\n  }\n  delete emoji.tokens;\n  if (emoji.skinTones) {\n    const len = emoji.skinTones.length;\n    emoji.skins = Array(len);\n    for (let i = 0; i < len; i++) {\n      emoji.skins[i] = {\n        tone: emoji.skinTones[i],\n        unicode: emoji.skinUnicodes[i],\n        version: emoji.skinVersions[i]\n      };\n    }\n    delete emoji.skinTones;\n    delete emoji.skinUnicodes;\n    delete emoji.skinVersions;\n  }\n  return emoji\n}\n\nfunction warnETag (eTag) {\n  if (!eTag) {\n    console.warn('emoji-picker-element is more efficient if the dataSource server exposes an ETag header.');\n  }\n}\n\nconst requiredKeys = [\n  'annotation',\n  'emoji',\n  'group',\n  'order',\n  'tags',\n  'version'\n];\n\nfunction assertEmojiData (emojiData) {\n  if (!emojiData ||\n    !Array.isArray(emojiData) ||\n    !emojiData[0] ||\n    (typeof emojiData[0] !== 'object') ||\n    requiredKeys.some(key => (!(key in emojiData[0])))) {\n    throw new Error('Emoji data is in the wrong format')\n  }\n}\n\nfunction assertStatus (response, dataSource) {\n  if (Math.floor(response.status / 100) !== 2) {\n    throw new Error('Failed to fetch: ' + dataSource + ':  ' + response.status)\n  }\n}\n\nasync function getETag (dataSource) {\n  const response = await fetch(dataSource, { method: 'HEAD' });\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  return eTag\n}\n\nasync function getETagAndData (dataSource) {\n  const response = await fetch(dataSource);\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  const emojiData = await response.json();\n  assertEmojiData(emojiData);\n  return [eTag, emojiData]\n}\n\n// TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n/**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */\nfunction arrayBufferToBinaryString(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    var length = bytes.byteLength;\n    var i = -1;\n    while (++i < length) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */\nfunction binaryStringToArrayBuffer(binary) {\n    var length = binary.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    var i = -1;\n    while (++i < length) {\n        arr[i] = binary.charCodeAt(i);\n    }\n    return buf;\n}\n\n// generate a checksum based on the stringified JSON\nasync function jsonChecksum (object) {\n  const inString = JSON.stringify(object);\n  const inBuffer = binaryStringToArrayBuffer(inString);\n  // this does not need to be cryptographically secure, SHA-1 is fine\n  const outBuffer = await crypto.subtle.digest('SHA-1', inBuffer);\n  const outBinString = arrayBufferToBinaryString(outBuffer);\n  const res = btoa(outBinString);\n  return res\n}\n\nasync function checkForUpdates (db, dataSource) {\n  // just do a simple HEAD request first to see if the eTags match\n  let emojiData;\n  let eTag = await getETag(dataSource);\n  if (!eTag) { // work around lack of ETag/Access-Control-Expose-Headers\n    const eTagAndData = await getETagAndData(dataSource);\n    eTag = eTagAndData[0];\n    emojiData = eTagAndData[1];\n    if (!eTag) {\n      eTag = await jsonChecksum(emojiData);\n    }\n  }\n  if (await hasData(db, dataSource, eTag)) ; else {\n    if (!emojiData) {\n      const eTagAndData = await getETagAndData(dataSource);\n      emojiData = eTagAndData[1];\n    }\n    await loadData(db, emojiData, dataSource, eTag);\n  }\n}\n\nasync function loadDataForFirstTime (db, dataSource) {\n  let [eTag, emojiData] = await getETagAndData(dataSource);\n  if (!eTag) {\n    // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await jsonChecksum(emojiData);\n  }\n\n  await loadData(db, emojiData, dataSource, eTag);\n}\n\nclass Database {\n  constructor ({ dataSource = DEFAULT_DATA_SOURCE, locale = DEFAULT_LOCALE, customEmoji = [] } = {}) {\n    this.dataSource = dataSource;\n    this.locale = locale;\n    this._dbName = `emoji-picker-element-${this.locale}`;\n    this._db = undefined;\n    this._lazyUpdate = undefined;\n    this._custom = customEmojiIndex(customEmoji);\n\n    this._clear = this._clear.bind(this);\n    this._ready = this._init();\n  }\n\n  async _init () {\n    const db = this._db = await openDatabase(this._dbName);\n\n    addOnCloseListener(this._dbName, this._clear);\n    const dataSource = this.dataSource;\n    const empty = await isEmpty(db);\n\n    if (empty) {\n      await loadDataForFirstTime(db, dataSource);\n    } else { // offline-first - do an update asynchronously\n      this._lazyUpdate = checkForUpdates(db, dataSource);\n    }\n  }\n\n  async ready () {\n    const checkReady = async () => {\n      if (!this._ready) {\n        this._ready = this._init();\n      }\n      return this._ready\n    };\n    await checkReady();\n    // There's a possibility of a race condition where the element gets added, removed, and then added again\n    // with a particular timing, which would set the _db to undefined.\n    // We *could* do a while loop here, but that seems excessive and could lead to an infinite loop.\n    if (!this._db) {\n      await checkReady();\n    }\n  }\n\n  async getEmojiByGroup (group) {\n    assertNumber(group);\n    await this.ready();\n    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji)\n  }\n\n  async getEmojiBySearchQuery (query) {\n    assertNonEmptyString(query);\n    await this.ready();\n    const customs = this._custom.search(query);\n    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);\n    return [\n      ...customs,\n      ...natives\n    ]\n  }\n\n  async getEmojiByShortcode (shortcode) {\n    assertNonEmptyString(shortcode);\n    await this.ready();\n    const custom = this._custom.byShortcode(shortcode);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode))\n  }\n\n  async getEmojiByUnicodeOrName (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    const custom = this._custom.byName(unicodeOrName);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName))\n  }\n\n  async getPreferredSkinTone () {\n    await this.ready();\n    return (await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE)) || 0\n  }\n\n  async setPreferredSkinTone (skinTone) {\n    assertNumber(skinTone);\n    await this.ready();\n    return set(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone)\n  }\n\n  async incrementFavoriteEmojiCount (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    return incrementFavoriteEmojiCount(this._db, unicodeOrName)\n  }\n\n  async getTopFavoriteEmoji (limit) {\n    assertNumber(limit);\n    await this.ready();\n    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji)\n  }\n\n  set customEmoji (customEmojis) {\n    this._custom = customEmojiIndex(customEmojis);\n  }\n\n  get customEmoji () {\n    return this._custom.all\n  }\n\n  async _shutdown () {\n    await this.ready(); // reopen if we've already been closed/deleted\n    try {\n      await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n    } catch (err) { /* ignore network errors (offline-first) */ }\n  }\n\n  // clear references to IDB, e.g. during a close event\n  _clear () {\n    // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n    // The memory leak tests prove this is unnecessary. It's because:\n    // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n    // 2) we clear the manual close listeners in databaseLifecycle.js.\n    this._db = this._ready = this._lazyUpdate = undefined;\n  }\n\n  async close () {\n    await this._shutdown();\n    await closeDatabase(this._dbName);\n  }\n\n  async delete () {\n    await this._shutdown();\n    await deleteDatabase(this._dbName);\n  }\n}\n\nexport { Database as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}