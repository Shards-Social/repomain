{"ast":null,"code":"function assertNonEmptyString(str) {\n  if (typeof str !== 'string' || !str) {\n    throw new Error('expected a non-empty string, got: ' + str);\n  }\n}\nfunction assertNumber(number) {\n  if (typeof number !== 'number') {\n    throw new Error('expected a number, got: ' + number);\n  }\n}\nconst DB_VERSION_CURRENT = 1;\nconst DB_VERSION_INITIAL = 1;\nconst STORE_EMOJI = 'emoji';\nconst STORE_KEYVALUE = 'keyvalue';\nconst STORE_FAVORITES = 'favorites';\nconst FIELD_TOKENS = 'tokens';\nconst INDEX_TOKENS = 'tokens';\nconst FIELD_UNICODE = 'unicode';\nconst INDEX_COUNT = 'count';\nconst FIELD_GROUP = 'group';\nconst FIELD_ORDER = 'order';\nconst INDEX_GROUP_AND_ORDER = 'group-order';\nconst KEY_ETAG = 'eTag';\nconst KEY_URL = 'url';\nconst KEY_PREFERRED_SKINTONE = 'skinTone';\nconst MODE_READONLY = 'readonly';\nconst MODE_READWRITE = 'readwrite';\nconst INDEX_SKIN_UNICODE = 'skinUnicodes';\nconst FIELD_SKIN_UNICODE = 'skinUnicodes';\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json';\nconst DEFAULT_LOCALE = 'en';\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy(arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res;\n}\nfunction uniqEmoji(emojis) {\n  return uniqBy(emojis, _ => _.unicode);\n}\nfunction initialMigration(db) {\n  function createObjectStore(name, keyPath, indexes) {\n    const store = keyPath ? db.createObjectStore(name, {\n      keyPath\n    }) : db.createObjectStore(name);\n    if (indexes) {\n      for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes)) {\n        store.createIndex(indexName, keyPath, {\n          multiEntry\n        });\n      }\n    }\n    return store;\n  }\n  createObjectStore(STORE_KEYVALUE);\n  createObjectStore(STORE_EMOJI, /* keyPath */FIELD_UNICODE, {\n    [INDEX_TOKENS]: [FIELD_TOKENS, /* multiEntry */true],\n    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],\n    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, /* multiEntry */true]\n  });\n  createObjectStore(STORE_FAVORITES, undefined, {\n    [INDEX_COUNT]: ['']\n  });\n}\nconst openReqs = {};\nconst databaseCache = {};\nconst onCloseListeners = {};\nfunction handleOpenOrDeleteReq(resolve, reject, req) {\n  // These things are almost impossible to test with fakeIndexedDB sadly\n  /* istanbul ignore next */\n  req.onerror = () => reject(req.error);\n  /* istanbul ignore next */\n  req.onblocked = () => reject(new Error('IDB blocked'));\n  req.onsuccess = () => resolve(req.result);\n}\nasync function createDatabase(dbName) {\n  const db = await new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);\n    openReqs[dbName] = req;\n    req.onupgradeneeded = e => {\n      // Technically there is only one version, so we don't need this `if` check\n      // But if an old version of the JS is in another browser tab\n      // and it gets upgraded in the future and we have a new DB version, well...\n      // better safe than sorry.\n      /* istanbul ignore else */\n      if (e.oldVersion < DB_VERSION_INITIAL) {\n        initialMigration(req.result);\n      }\n    };\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n  // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n  // No need for removeEventListener, because once the DB can no longer\n  // fire \"close\" events, it will auto-GC.\n  // Unfortunately cannot test in fakeIndexedDB: https://github.com/dumbmatter/fakeIndexedDB/issues/50\n  /* istanbul ignore next */\n  db.onclose = () => closeDatabase(dbName);\n  return db;\n}\nfunction openDatabase(dbName) {\n  if (!databaseCache[dbName]) {\n    databaseCache[dbName] = createDatabase(dbName);\n  }\n  return databaseCache[dbName];\n}\nfunction dbPromise(db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    // Use relaxed durability because neither the emoji data nor the favorites/preferred skin tone\n    // are really irreplaceable data. IndexedDB is just a cache in this case.\n    const txn = db.transaction(storeName, readOnlyOrReadWrite, {\n      durability: 'relaxed'\n    });\n    const store = typeof storeName === 'string' ? txn.objectStore(storeName) : storeName.map(name => txn.objectStore(name));\n    let res;\n    cb(store, txn, result => {\n      res = result;\n    });\n    txn.oncomplete = () => resolve(res);\n    /* istanbul ignore next */\n    txn.onerror = () => reject(txn.error);\n  });\n}\nfunction closeDatabase(dbName) {\n  // close any open requests\n  const req = openReqs[dbName];\n  const db = req && req.result;\n  if (db) {\n    db.close();\n    const listeners = onCloseListeners[dbName];\n    /* istanbul ignore else */\n    if (listeners) {\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  }\n  delete openReqs[dbName];\n  delete databaseCache[dbName];\n  delete onCloseListeners[dbName];\n}\nfunction deleteDatabase(dbName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    closeDatabase(dbName);\n    const req = indexedDB.deleteDatabase(dbName);\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n}\n\n// The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\nfunction addOnCloseListener(dbName, listener) {\n  let listeners = onCloseListeners[dbName];\n  if (!listeners) {\n    listeners = onCloseListeners[dbName] = [];\n  }\n  listeners.push(listener);\n}\n\n// list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emoji-picker-element-data/en/emojibase/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\nconst irregularEmoticons = new Set([':D', 'XD', \":'D\", 'O:)', ':X', ':P', ';P', 'XP', ':L', ':Z', ':j', '8D', 'XO', '8)', ':B', ':O', ':S', \":'o\", 'Dx', 'X(', 'D:', ':C', '>0)', ':3', '</3', '<3', '\\\\M/', ':E', '8#']);\nfunction extractTokens(str) {\n  return str.split(/[\\s_]+/).map(word => {\n    if (!word.match(/\\w/) || irregularEmoticons.has(word)) {\n      // for pure emoticons like :) or :-), just leave them as-is\n      return word.toLowerCase();\n    }\n    return word.replace(/[)(:,]/g, '').replace(/’/g, \"'\").toLowerCase();\n  }).filter(Boolean);\n}\nconst MIN_SEARCH_TEXT_LENGTH = 2;\n\n// This is an extra step in addition to extractTokens(). The difference here is that we expect\n// the input to have already been run through extractTokens(). This is useful for cases like\n// emoticons, where we don't want to do any tokenization (because it makes no sense to split up\n// \">:)\" by the colon) but we do want to lowercase it to have consistent search results, so that\n// the user can type ':P' or ':p' and still get the same result.\nfunction normalizeTokens(str) {\n  return str.filter(Boolean).map(_ => _.toLowerCase()).filter(_ => _.length >= MIN_SEARCH_TEXT_LENGTH);\n}\n\n// Transform emoji data for storage in IDB\nfunction transformEmojiData(emojiData) {\n  const res = emojiData.map(_ref => {\n    let {\n      annotation,\n      emoticon,\n      group,\n      order,\n      shortcodes,\n      skins,\n      tags,\n      emoji,\n      version\n    } = _ref;\n    const tokens = [...new Set(normalizeTokens([...(shortcodes || []).map(extractTokens).flat(), ...tags.map(extractTokens).flat(), ...extractTokens(annotation), emoticon]))].sort();\n    const res = {\n      annotation,\n      group,\n      order,\n      tags,\n      tokens,\n      unicode: emoji,\n      version\n    };\n    if (emoticon) {\n      res.emoticon = emoticon;\n    }\n    if (shortcodes) {\n      res.shortcodes = shortcodes;\n    }\n    if (skins) {\n      res.skinTones = [];\n      res.skinUnicodes = [];\n      res.skinVersions = [];\n      for (const {\n        tone,\n        emoji,\n        version\n      } of skins) {\n        res.skinTones.push(tone);\n        res.skinUnicodes.push(emoji);\n        res.skinVersions.push(version);\n      }\n    }\n    return res;\n  });\n  return res;\n}\n\n// helper functions that help compress the code better\n\nfunction callStore(store, method, key, cb) {\n  store[method](key).onsuccess = e => cb && cb(e.target.result);\n}\nfunction getIDB(store, key, cb) {\n  callStore(store, 'get', key, cb);\n}\nfunction getAllIDB(store, key, cb) {\n  callStore(store, 'getAll', key, cb);\n}\nfunction commit(txn) {\n  /* istanbul ignore else */\n  if (txn.commit) {\n    txn.commit();\n  }\n}\n\n// like lodash's minBy\nfunction minBy(array, func) {\n  let minItem = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (func(minItem) > func(item)) {\n      minItem = item;\n    }\n  }\n  return minItem;\n}\n\n// return an array of results representing all items that are found in each one of the arrays\n\nfunction findCommonMembers(arrays, uniqByFunc) {\n  const shortestArray = minBy(arrays, _ => _.length);\n  const results = [];\n  for (const item of shortestArray) {\n    // if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some(array => array.findIndex(_ => uniqByFunc(_) === uniqByFunc(item)) === -1)) {\n      results.push(item);\n    }\n  }\n  return results;\n}\nasync function isEmpty(db) {\n  return !(await get(db, STORE_KEYVALUE, KEY_URL));\n}\nasync function hasData(db, url, eTag) {\n  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL].map(key => get(db, STORE_KEYVALUE, key)));\n  return oldETag === eTag && oldUrl === url;\n}\nasync function doFullDatabaseScanForSingleResult(db, predicate) {\n  // This batching algorithm is just a perf improvement over a basic\n  // cursor. The BATCH_SIZE is an estimate of what would give the best\n  // perf for doing a full DB scan (worst case).\n  //\n  // Mini-benchmark for determining the best batch size:\n  //\n  // PERF=1 yarn build:rollup && yarn test:adhoc\n  //\n  // (async () => {\n  //   performance.mark('start')\n  //   await $('emoji-picker').database.getEmojiByShortcode('doesnotexist')\n  //   performance.measure('total', 'start')\n  //   console.log(performance.getEntriesByName('total').slice(-1)[0].duration)\n  // })()\n  const BATCH_SIZE = 50; // Typically around 150ms for 6x slowdown in Chrome for above benchmark\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    let lastKey;\n    const processNextBatch = () => {\n      emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = e => {\n        const results = e.target.result;\n        for (const result of results) {\n          lastKey = result.unicode;\n          if (predicate(result)) {\n            return cb(result);\n          }\n        }\n        if (results.length < BATCH_SIZE) {\n          return cb();\n        }\n        processNextBatch();\n      };\n    };\n    processNextBatch();\n  });\n}\nasync function loadData(db, emojiData, url, eTag) {\n  try {\n    const transformedData = transformEmojiData(emojiData);\n    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, (_ref2, txn) => {\n      let [emojiStore, metaStore] = _ref2;\n      let oldETag;\n      let oldUrl;\n      let todo = 0;\n      function checkFetched() {\n        if (++todo === 2) {\n          // 2 requests made\n          onFetched();\n        }\n      }\n      function onFetched() {\n        if (oldETag === eTag && oldUrl === url) {\n          // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n          return;\n        }\n        // delete old data\n        emojiStore.clear();\n        // insert new data\n        for (const data of transformedData) {\n          emojiStore.put(data);\n        }\n        metaStore.put(eTag, KEY_ETAG);\n        metaStore.put(url, KEY_URL);\n        commit(txn);\n      }\n      getIDB(metaStore, KEY_ETAG, result => {\n        oldETag = result;\n        checkFetched();\n      });\n      getIDB(metaStore, KEY_URL, result => {\n        oldUrl = result;\n        checkFetched();\n      });\n    });\n  } finally {}\n}\nasync function getEmojiByGroup(db, group) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);\n    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);\n  });\n}\nasync function getEmojiBySearchQuery(db, query) {\n  const tokens = normalizeTokens(extractTokens(query));\n  if (!tokens.length) {\n    return [];\n  }\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    // get all results that contain all tokens (i.e. an AND query)\n    const intermediateResults = [];\n    const checkDone = () => {\n      if (intermediateResults.length === tokens.length) {\n        onDone();\n      }\n    };\n    const onDone = () => {\n      const results = findCommonMembers(intermediateResults, _ => _.unicode);\n      cb(results.sort((a, b) => a.order < b.order ? -1 : 1));\n    };\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const range = i === tokens.length - 1 ? IDBKeyRange.bound(token, token + '\\uffff', false, true) // treat last token as a prefix search\n      : IDBKeyRange.only(token); // treat all other tokens as an exact match\n      getAllIDB(emojiStore.index(INDEX_TOKENS), range, result => {\n        intermediateResults.push(result);\n        checkDone();\n      });\n    }\n  });\n}\n\n// This could have been implemented as an IDB index on shortcodes, but it seemed wasteful to do that\n// when we can already query by tokens and this will give us what we're looking for 99.9% of the time\nasync function getEmojiByShortcode(db, shortcode) {\n  const emojis = await getEmojiBySearchQuery(db, shortcode);\n\n  // In very rare cases (e.g. the shortcode \"v\" as in \"v for victory\"), we cannot search because\n  // there are no usable tokens (too short in this case). In that case, we have to do an inefficient\n  // full-database scan, which I believe is an acceptable tradeoff for not having to have an extra\n  // index on shortcodes.\n\n  if (!emojis.length) {\n    const predicate = _ => (_.shortcodes || []).includes(shortcode.toLowerCase());\n    return (await doFullDatabaseScanForSingleResult(db, predicate)) || null;\n  }\n  return emojis.filter(_ => {\n    const lowerShortcodes = (_.shortcodes || []).map(_ => _.toLowerCase());\n    return lowerShortcodes.includes(shortcode.toLowerCase());\n  })[0] || null;\n}\nasync function getEmojiByUnicode(db, unicode) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => getIDB(emojiStore, unicode, result => {\n    if (result) {\n      return cb(result);\n    }\n    getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, result => cb(result || null));\n  }));\n}\nfunction get(db, storeName, key) {\n  return dbPromise(db, storeName, MODE_READONLY, (store, txn, cb) => getIDB(store, key, cb));\n}\nfunction set(db, storeName, key, value) {\n  return dbPromise(db, storeName, MODE_READWRITE, (store, txn) => {\n    store.put(value, key);\n    commit(txn);\n  });\n}\nfunction incrementFavoriteEmojiCount(db, unicode) {\n  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store, txn) => getIDB(store, unicode, result => {\n    store.put((result || 0) + 1, unicode);\n    commit(txn);\n  }));\n}\nfunction getTopFavoriteEmoji(db, customEmojiIndex, limit) {\n  if (limit === 0) {\n    return [];\n  }\n  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, (_ref3, txn, cb) => {\n    let [favoritesStore, emojiStore] = _ref3;\n    const results = [];\n    favoritesStore.index(INDEX_COUNT).openCursor(undefined, 'prev').onsuccess = e => {\n      const cursor = e.target.result;\n      if (!cursor) {\n        // no more results\n        return cb(results);\n      }\n      function addResult(result) {\n        results.push(result);\n        if (results.length === limit) {\n          return cb(results); // done, reached the limit\n        }\n        cursor.continue();\n      }\n      const unicodeOrName = cursor.primaryKey;\n      const custom = customEmojiIndex.byName(unicodeOrName);\n      if (custom) {\n        return addResult(custom);\n      }\n      // This could be done in parallel (i.e. make the cursor and the get()s parallelized),\n      // but my testing suggests it's not actually faster.\n      getIDB(emojiStore, unicodeOrName, emoji => {\n        if (emoji) {\n          return addResult(emoji);\n        }\n        // emoji not found somehow, ignore (may happen if custom emoji change)\n        cursor.continue();\n      });\n    };\n  });\n}\n\n// trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\n\nconst CODA_MARKER = ''; // marks the end of the string\n\nfunction trie(arr, itemToTokens) {\n  const map = new Map();\n  for (const item of arr) {\n    const tokens = itemToTokens(item);\n    for (const token of tokens) {\n      let currentMap = map;\n      for (let i = 0; i < token.length; i++) {\n        const char = token.charAt(i);\n        let nextMap = currentMap.get(char);\n        if (!nextMap) {\n          nextMap = new Map();\n          currentMap.set(char, nextMap);\n        }\n        currentMap = nextMap;\n      }\n      let valuesAtCoda = currentMap.get(CODA_MARKER);\n      if (!valuesAtCoda) {\n        valuesAtCoda = [];\n        currentMap.set(CODA_MARKER, valuesAtCoda);\n      }\n      valuesAtCoda.push(item);\n    }\n  }\n  const search = (query, exact) => {\n    let currentMap = map;\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charAt(i);\n      const nextMap = currentMap.get(char);\n      if (nextMap) {\n        currentMap = nextMap;\n      } else {\n        return [];\n      }\n    }\n    if (exact) {\n      const results = currentMap.get(CODA_MARKER);\n      return results || [];\n    }\n    const results = [];\n    // traverse\n    const queue = [currentMap];\n    while (queue.length) {\n      const currentMap = queue.shift();\n      const entriesSortedByKey = [...currentMap.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);\n      for (const [key, value] of entriesSortedByKey) {\n        if (key === CODA_MARKER) {\n          // CODA_MARKER always comes first; it's the empty string\n          results.push(...value);\n        } else {\n          queue.push(value);\n        }\n      }\n    }\n    return results;\n  };\n  return search;\n}\nconst requiredKeys$1 = ['name', 'url'];\nfunction assertCustomEmojis(customEmojis) {\n  const isArray = customEmojis && Array.isArray(customEmojis);\n  const firstItemIsFaulty = isArray && customEmojis.length && (!customEmojis[0] || requiredKeys$1.some(key => !(key in customEmojis[0])));\n  if (!isArray || firstItemIsFaulty) {\n    throw new Error('Custom emojis are in the wrong format');\n  }\n}\nfunction customEmojiIndex(customEmojis) {\n  assertCustomEmojis(customEmojis);\n  const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;\n\n  //\n  // all()\n  //\n  const all = customEmojis.sort(sortByName);\n\n  //\n  // search()\n  //\n  const emojiToTokens = emoji => [...new Set((emoji.shortcodes || []).map(shortcode => extractTokens(shortcode)).flat())];\n  const searchTrie = trie(customEmojis, emojiToTokens);\n  const searchByExactMatch = _ => searchTrie(_, true);\n  const searchByPrefix = _ => searchTrie(_, false);\n\n  // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n  // is treated as a prefix search, but every other one is treated as an exact match.\n  // Then we AND the results together\n  const search = query => {\n    const tokens = extractTokens(query);\n    const intermediateResults = tokens.map((token, i) => (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token));\n    return findCommonMembers(intermediateResults, _ => _.name).sort(sortByName);\n  };\n\n  //\n  // byShortcode, byName\n  //\n  const shortcodeToEmoji = new Map();\n  const nameToEmoji = new Map();\n  for (const customEmoji of customEmojis) {\n    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n    for (const shortcode of customEmoji.shortcodes || []) {\n      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n  }\n  const byShortcode = shortcode => shortcodeToEmoji.get(shortcode.toLowerCase());\n  const byName = name => nameToEmoji.get(name.toLowerCase());\n  return {\n    all,\n    search,\n    byShortcode,\n    byName\n  };\n}\n\n// remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\nfunction cleanEmoji(emoji) {\n  if (!emoji) {\n    return emoji;\n  }\n  delete emoji.tokens;\n  if (emoji.skinTones) {\n    const len = emoji.skinTones.length;\n    emoji.skins = Array(len);\n    for (let i = 0; i < len; i++) {\n      emoji.skins[i] = {\n        tone: emoji.skinTones[i],\n        unicode: emoji.skinUnicodes[i],\n        version: emoji.skinVersions[i]\n      };\n    }\n    delete emoji.skinTones;\n    delete emoji.skinUnicodes;\n    delete emoji.skinVersions;\n  }\n  return emoji;\n}\nfunction warnETag(eTag) {\n  if (!eTag) {\n    console.warn('emoji-picker-element is more efficient if the dataSource server exposes an ETag header.');\n  }\n}\nconst requiredKeys = ['annotation', 'emoji', 'group', 'order', 'tags', 'version'];\nfunction assertEmojiData(emojiData) {\n  if (!emojiData || !Array.isArray(emojiData) || !emojiData[0] || typeof emojiData[0] !== 'object' || requiredKeys.some(key => !(key in emojiData[0]))) {\n    throw new Error('Emoji data is in the wrong format');\n  }\n}\nfunction assertStatus(response, dataSource) {\n  if (Math.floor(response.status / 100) !== 2) {\n    throw new Error('Failed to fetch: ' + dataSource + ':  ' + response.status);\n  }\n}\nasync function getETag(dataSource) {\n  const response = await fetch(dataSource, {\n    method: 'HEAD'\n  });\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  return eTag;\n}\nasync function getETagAndData(dataSource) {\n  const response = await fetch(dataSource);\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  const emojiData = await response.json();\n  assertEmojiData(emojiData);\n  return [eTag, emojiData];\n}\n\n// TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n/**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  var i = -1;\n  while (++i < length) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */\nfunction binaryStringToArrayBuffer(binary) {\n  var length = binary.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  var i = -1;\n  while (++i < length) {\n    arr[i] = binary.charCodeAt(i);\n  }\n  return buf;\n}\n\n// generate a checksum based on the stringified JSON\nasync function jsonChecksum(object) {\n  const inString = JSON.stringify(object);\n  const inBuffer = binaryStringToArrayBuffer(inString);\n  // this does not need to be cryptographically secure, SHA-1 is fine\n  const outBuffer = await crypto.subtle.digest('SHA-1', inBuffer);\n  const outBinString = arrayBufferToBinaryString(outBuffer);\n  const res = btoa(outBinString);\n  return res;\n}\nasync function checkForUpdates(db, dataSource) {\n  // just do a simple HEAD request first to see if the eTags match\n  let emojiData;\n  let eTag = await getETag(dataSource);\n  if (!eTag) {\n    // work around lack of ETag/Access-Control-Expose-Headers\n    const eTagAndData = await getETagAndData(dataSource);\n    eTag = eTagAndData[0];\n    emojiData = eTagAndData[1];\n    if (!eTag) {\n      eTag = await jsonChecksum(emojiData);\n    }\n  }\n  if (await hasData(db, dataSource, eTag)) ;else {\n    if (!emojiData) {\n      const eTagAndData = await getETagAndData(dataSource);\n      emojiData = eTagAndData[1];\n    }\n    await loadData(db, emojiData, dataSource, eTag);\n  }\n}\nasync function loadDataForFirstTime(db, dataSource) {\n  let [eTag, emojiData] = await getETagAndData(dataSource);\n  if (!eTag) {\n    // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await jsonChecksum(emojiData);\n  }\n  await loadData(db, emojiData, dataSource, eTag);\n}\nclass Database {\n  constructor() {\n    let {\n      dataSource = DEFAULT_DATA_SOURCE,\n      locale = DEFAULT_LOCALE,\n      customEmoji = []\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.dataSource = dataSource;\n    this.locale = locale;\n    this._dbName = \"emoji-picker-element-\".concat(this.locale);\n    this._db = undefined;\n    this._lazyUpdate = undefined;\n    this._custom = customEmojiIndex(customEmoji);\n    this._clear = this._clear.bind(this);\n    this._ready = this._init();\n  }\n  async _init() {\n    const db = this._db = await openDatabase(this._dbName);\n    addOnCloseListener(this._dbName, this._clear);\n    const dataSource = this.dataSource;\n    const empty = await isEmpty(db);\n    if (empty) {\n      await loadDataForFirstTime(db, dataSource);\n    } else {\n      // offline-first - do an update asynchronously\n      this._lazyUpdate = checkForUpdates(db, dataSource);\n    }\n  }\n  async ready() {\n    const checkReady = async () => {\n      if (!this._ready) {\n        this._ready = this._init();\n      }\n      return this._ready;\n    };\n    await checkReady();\n    // There's a possibility of a race condition where the element gets added, removed, and then added again\n    // with a particular timing, which would set the _db to undefined.\n    // We *could* do a while loop here, but that seems excessive and could lead to an infinite loop.\n    if (!this._db) {\n      await checkReady();\n    }\n  }\n  async getEmojiByGroup(group) {\n    assertNumber(group);\n    await this.ready();\n    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji);\n  }\n  async getEmojiBySearchQuery(query) {\n    assertNonEmptyString(query);\n    await this.ready();\n    const customs = this._custom.search(query);\n    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);\n    return [...customs, ...natives];\n  }\n  async getEmojiByShortcode(shortcode) {\n    assertNonEmptyString(shortcode);\n    await this.ready();\n    const custom = this._custom.byShortcode(shortcode);\n    if (custom) {\n      return custom;\n    }\n    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode));\n  }\n  async getEmojiByUnicodeOrName(unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    const custom = this._custom.byName(unicodeOrName);\n    if (custom) {\n      return custom;\n    }\n    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName));\n  }\n  async getPreferredSkinTone() {\n    await this.ready();\n    return (await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE)) || 0;\n  }\n  async setPreferredSkinTone(skinTone) {\n    assertNumber(skinTone);\n    await this.ready();\n    return set(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone);\n  }\n  async incrementFavoriteEmojiCount(unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    return incrementFavoriteEmojiCount(this._db, unicodeOrName);\n  }\n  async getTopFavoriteEmoji(limit) {\n    assertNumber(limit);\n    await this.ready();\n    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji);\n  }\n  set customEmoji(customEmojis) {\n    this._custom = customEmojiIndex(customEmojis);\n  }\n  get customEmoji() {\n    return this._custom.all;\n  }\n  async _shutdown() {\n    await this.ready(); // reopen if we've already been closed/deleted\n    try {\n      await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n    } catch (err) {/* ignore network errors (offline-first) */}\n  }\n\n  // clear references to IDB, e.g. during a close event\n  _clear() {\n    // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n    // The memory leak tests prove this is unnecessary. It's because:\n    // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n    // 2) we clear the manual close listeners in databaseLifecycle.js.\n    this._db = this._ready = this._lazyUpdate = undefined;\n  }\n  async close() {\n    await this._shutdown();\n    await closeDatabase(this._dbName);\n  }\n  async delete() {\n    await this._shutdown();\n    await deleteDatabase(this._dbName);\n  }\n}\nexport { Database as default };","map":{"version":3,"names":["assertNonEmptyString","str","Error","assertNumber","number","DB_VERSION_CURRENT","DB_VERSION_INITIAL","STORE_EMOJI","STORE_KEYVALUE","STORE_FAVORITES","FIELD_TOKENS","INDEX_TOKENS","FIELD_UNICODE","INDEX_COUNT","FIELD_GROUP","FIELD_ORDER","INDEX_GROUP_AND_ORDER","KEY_ETAG","KEY_URL","KEY_PREFERRED_SKINTONE","MODE_READONLY","MODE_READWRITE","INDEX_SKIN_UNICODE","FIELD_SKIN_UNICODE","DEFAULT_DATA_SOURCE","DEFAULT_LOCALE","uniqBy","arr","func","set","Set","res","item","key","has","add","push","uniqEmoji","emojis","_","unicode","initialMigration","db","createObjectStore","name","keyPath","indexes","store","indexName","multiEntry","Object","entries","createIndex","undefined","openReqs","databaseCache","onCloseListeners","handleOpenOrDeleteReq","resolve","reject","req","onerror","error","onblocked","onsuccess","result","createDatabase","dbName","Promise","indexedDB","open","onupgradeneeded","e","oldVersion","onclose","closeDatabase","openDatabase","dbPromise","storeName","readOnlyOrReadWrite","cb","txn","transaction","durability","objectStore","map","oncomplete","close","listeners","listener","deleteDatabase","addOnCloseListener","irregularEmoticons","extractTokens","split","word","match","toLowerCase","replace","filter","Boolean","MIN_SEARCH_TEXT_LENGTH","normalizeTokens","length","transformEmojiData","emojiData","_ref","annotation","emoticon","group","order","shortcodes","skins","tags","emoji","version","tokens","flat","sort","skinTones","skinUnicodes","skinVersions","tone","callStore","method","target","getIDB","getAllIDB","commit","minBy","array","minItem","i","findCommonMembers","arrays","uniqByFunc","shortestArray","results","some","findIndex","isEmpty","get","hasData","url","eTag","oldETag","oldUrl","all","doFullDatabaseScanForSingleResult","predicate","BATCH_SIZE","emojiStore","lastKey","processNextBatch","getAll","IDBKeyRange","lowerBound","loadData","transformedData","_ref2","metaStore","todo","checkFetched","onFetched","clear","data","put","getEmojiByGroup","range","bound","index","getEmojiBySearchQuery","query","intermediateResults","checkDone","onDone","a","b","token","only","getEmojiByShortcode","shortcode","includes","lowerShortcodes","getEmojiByUnicode","value","incrementFavoriteEmojiCount","getTopFavoriteEmoji","customEmojiIndex","limit","_ref3","favoritesStore","openCursor","cursor","addResult","continue","unicodeOrName","primaryKey","custom","byName","CODA_MARKER","trie","itemToTokens","Map","currentMap","char","charAt","nextMap","valuesAtCoda","search","exact","queue","shift","entriesSortedByKey","requiredKeys$1","assertCustomEmojis","customEmojis","isArray","Array","firstItemIsFaulty","sortByName","emojiToTokens","searchTrie","searchByExactMatch","searchByPrefix","shortcodeToEmoji","nameToEmoji","customEmoji","byShortcode","cleanEmoji","len","warnETag","console","warn","requiredKeys","assertEmojiData","assertStatus","response","dataSource","Math","floor","status","getETag","fetch","headers","getETagAndData","json","arrayBufferToBinaryString","buffer","binary","bytes","Uint8Array","byteLength","String","fromCharCode","binaryStringToArrayBuffer","buf","ArrayBuffer","charCodeAt","jsonChecksum","object","inString","JSON","stringify","inBuffer","outBuffer","crypto","subtle","digest","outBinString","btoa","checkForUpdates","eTagAndData","loadDataForFirstTime","Database","constructor","locale","arguments","_dbName","concat","_db","_lazyUpdate","_custom","_clear","bind","_ready","_init","empty","ready","checkReady","customs","natives","getEmojiByUnicodeOrName","getPreferredSkinTone","setPreferredSkinTone","skinTone","_shutdown","err","delete","default"],"sources":["C:/Users/samth/repomain-1/node_modules/emoji-picker-element/database.js"],"sourcesContent":["function assertNonEmptyString (str) {\n  if (typeof str !== 'string' || !str) {\n    throw new Error('expected a non-empty string, got: ' + str)\n  }\n}\n\nfunction assertNumber (number) {\n  if (typeof number !== 'number') {\n    throw new Error('expected a number, got: ' + number)\n  }\n}\n\nconst DB_VERSION_CURRENT = 1;\nconst DB_VERSION_INITIAL = 1;\nconst STORE_EMOJI = 'emoji';\nconst STORE_KEYVALUE = 'keyvalue';\nconst STORE_FAVORITES = 'favorites';\nconst FIELD_TOKENS = 'tokens';\nconst INDEX_TOKENS = 'tokens';\nconst FIELD_UNICODE = 'unicode';\nconst INDEX_COUNT = 'count';\nconst FIELD_GROUP = 'group';\nconst FIELD_ORDER = 'order';\nconst INDEX_GROUP_AND_ORDER = 'group-order';\nconst KEY_ETAG = 'eTag';\nconst KEY_URL = 'url';\nconst KEY_PREFERRED_SKINTONE = 'skinTone';\nconst MODE_READONLY = 'readonly';\nconst MODE_READWRITE = 'readwrite';\nconst INDEX_SKIN_UNICODE = 'skinUnicodes';\nconst FIELD_SKIN_UNICODE = 'skinUnicodes';\n\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json';\nconst DEFAULT_LOCALE = 'en';\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy (arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res\n}\n\nfunction uniqEmoji (emojis) {\n  return uniqBy(emojis, _ => _.unicode)\n}\n\nfunction initialMigration (db) {\n  function createObjectStore (name, keyPath, indexes) {\n    const store = keyPath\n      ? db.createObjectStore(name, { keyPath })\n      : db.createObjectStore(name);\n    if (indexes) {\n      for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes)) {\n        store.createIndex(indexName, keyPath, { multiEntry });\n      }\n    }\n    return store\n  }\n\n  createObjectStore(STORE_KEYVALUE);\n  createObjectStore(STORE_EMOJI, /* keyPath */ FIELD_UNICODE, {\n    [INDEX_TOKENS]: [FIELD_TOKENS, /* multiEntry */ true],\n    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],\n    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, /* multiEntry */ true]\n  });\n  createObjectStore(STORE_FAVORITES, undefined, {\n    [INDEX_COUNT]: ['']\n  });\n}\n\nconst openReqs = {};\nconst databaseCache = {};\nconst onCloseListeners = {};\n\nfunction handleOpenOrDeleteReq (resolve, reject, req) {\n  // These things are almost impossible to test with fakeIndexedDB sadly\n  /* istanbul ignore next */\n  req.onerror = () => reject(req.error);\n  /* istanbul ignore next */\n  req.onblocked = () => reject(new Error('IDB blocked'));\n  req.onsuccess = () => resolve(req.result);\n}\n\nasync function createDatabase (dbName) {\n  const db = await new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);\n    openReqs[dbName] = req;\n    req.onupgradeneeded = e => {\n      // Technically there is only one version, so we don't need this `if` check\n      // But if an old version of the JS is in another browser tab\n      // and it gets upgraded in the future and we have a new DB version, well...\n      // better safe than sorry.\n      /* istanbul ignore else */\n      if (e.oldVersion < DB_VERSION_INITIAL) {\n        initialMigration(req.result);\n      }\n    };\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n  // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n  // No need for removeEventListener, because once the DB can no longer\n  // fire \"close\" events, it will auto-GC.\n  // Unfortunately cannot test in fakeIndexedDB: https://github.com/dumbmatter/fakeIndexedDB/issues/50\n  /* istanbul ignore next */\n  db.onclose = () => closeDatabase(dbName);\n  return db\n}\n\nfunction openDatabase (dbName) {\n  if (!databaseCache[dbName]) {\n    databaseCache[dbName] = createDatabase(dbName);\n  }\n  return databaseCache[dbName]\n}\n\nfunction dbPromise (db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    // Use relaxed durability because neither the emoji data nor the favorites/preferred skin tone\n    // are really irreplaceable data. IndexedDB is just a cache in this case.\n    const txn = db.transaction(storeName, readOnlyOrReadWrite, { durability: 'relaxed' });\n    const store = typeof storeName === 'string'\n      ? txn.objectStore(storeName)\n      : storeName.map(name => txn.objectStore(name));\n    let res;\n    cb(store, txn, (result) => {\n      res = result;\n    });\n\n    txn.oncomplete = () => resolve(res);\n    /* istanbul ignore next */\n    txn.onerror = () => reject(txn.error);\n  })\n}\n\nfunction closeDatabase (dbName) {\n  // close any open requests\n  const req = openReqs[dbName];\n  const db = req && req.result;\n  if (db) {\n    db.close();\n    const listeners = onCloseListeners[dbName];\n    /* istanbul ignore else */\n    if (listeners) {\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  }\n  delete openReqs[dbName];\n  delete databaseCache[dbName];\n  delete onCloseListeners[dbName];\n}\n\nfunction deleteDatabase (dbName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    closeDatabase(dbName);\n    const req = indexedDB.deleteDatabase(dbName);\n    handleOpenOrDeleteReq(resolve, reject, req);\n  })\n}\n\n// The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\nfunction addOnCloseListener (dbName, listener) {\n  let listeners = onCloseListeners[dbName];\n  if (!listeners) {\n    listeners = onCloseListeners[dbName] = [];\n  }\n  listeners.push(listener);\n}\n\n// list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emoji-picker-element-data/en/emojibase/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\nconst irregularEmoticons = new Set([\n  ':D', 'XD', \":'D\", 'O:)',\n  ':X', ':P', ';P', 'XP',\n  ':L', ':Z', ':j', '8D',\n  'XO', '8)', ':B', ':O',\n  ':S', \":'o\", 'Dx', 'X(',\n  'D:', ':C', '>0)', ':3',\n  '</3', '<3', '\\\\M/', ':E',\n  '8#'\n]);\n\nfunction extractTokens (str) {\n  return str\n    .split(/[\\s_]+/)\n    .map(word => {\n      if (!word.match(/\\w/) || irregularEmoticons.has(word)) {\n        // for pure emoticons like :) or :-), just leave them as-is\n        return word.toLowerCase()\n      }\n\n      return word\n        .replace(/[)(:,]/g, '')\n        .replace(/’/g, \"'\")\n        .toLowerCase()\n    }).filter(Boolean)\n}\n\nconst MIN_SEARCH_TEXT_LENGTH = 2;\n\n// This is an extra step in addition to extractTokens(). The difference here is that we expect\n// the input to have already been run through extractTokens(). This is useful for cases like\n// emoticons, where we don't want to do any tokenization (because it makes no sense to split up\n// \">:)\" by the colon) but we do want to lowercase it to have consistent search results, so that\n// the user can type ':P' or ':p' and still get the same result.\nfunction normalizeTokens (str) {\n  return str\n    .filter(Boolean)\n    .map(_ => _.toLowerCase())\n    .filter(_ => _.length >= MIN_SEARCH_TEXT_LENGTH)\n}\n\n// Transform emoji data for storage in IDB\nfunction transformEmojiData (emojiData) {\n  const res = emojiData.map(({ annotation, emoticon, group, order, shortcodes, skins, tags, emoji, version }) => {\n    const tokens = [...new Set(\n      normalizeTokens([\n        ...(shortcodes || []).map(extractTokens).flat(),\n        ...tags.map(extractTokens).flat(),\n        ...extractTokens(annotation),\n        emoticon\n      ])\n    )].sort();\n    const res = {\n      annotation,\n      group,\n      order,\n      tags,\n      tokens,\n      unicode: emoji,\n      version\n    };\n    if (emoticon) {\n      res.emoticon = emoticon;\n    }\n    if (shortcodes) {\n      res.shortcodes = shortcodes;\n    }\n    if (skins) {\n      res.skinTones = [];\n      res.skinUnicodes = [];\n      res.skinVersions = [];\n      for (const { tone, emoji, version } of skins) {\n        res.skinTones.push(tone);\n        res.skinUnicodes.push(emoji);\n        res.skinVersions.push(version);\n      }\n    }\n    return res\n  });\n  return res\n}\n\n// helper functions that help compress the code better\n\nfunction callStore (store, method, key, cb) {\n  store[method](key).onsuccess = e => (cb && cb(e.target.result));\n}\n\nfunction getIDB (store, key, cb) {\n  callStore(store, 'get', key, cb);\n}\n\nfunction getAllIDB (store, key, cb) {\n  callStore(store, 'getAll', key, cb);\n}\n\nfunction commit (txn) {\n  /* istanbul ignore else */\n  if (txn.commit) {\n    txn.commit();\n  }\n}\n\n// like lodash's minBy\nfunction minBy (array, func) {\n  let minItem = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (func(minItem) > func(item)) {\n      minItem = item;\n    }\n  }\n  return minItem\n}\n\n// return an array of results representing all items that are found in each one of the arrays\n\nfunction findCommonMembers (arrays, uniqByFunc) {\n  const shortestArray = minBy(arrays, _ => _.length);\n  const results = [];\n  for (const item of shortestArray) {\n    // if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some(array => array.findIndex(_ => uniqByFunc(_) === uniqByFunc(item)) === -1)) {\n      results.push(item);\n    }\n  }\n  return results\n}\n\nasync function isEmpty (db) {\n  return !(await get(db, STORE_KEYVALUE, KEY_URL))\n}\n\nasync function hasData (db, url, eTag) {\n  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL]\n    .map(key => get(db, STORE_KEYVALUE, key)));\n  return (oldETag === eTag && oldUrl === url)\n}\n\nasync function doFullDatabaseScanForSingleResult (db, predicate) {\n  // This batching algorithm is just a perf improvement over a basic\n  // cursor. The BATCH_SIZE is an estimate of what would give the best\n  // perf for doing a full DB scan (worst case).\n  //\n  // Mini-benchmark for determining the best batch size:\n  //\n  // PERF=1 yarn build:rollup && yarn test:adhoc\n  //\n  // (async () => {\n  //   performance.mark('start')\n  //   await $('emoji-picker').database.getEmojiByShortcode('doesnotexist')\n  //   performance.measure('total', 'start')\n  //   console.log(performance.getEntriesByName('total').slice(-1)[0].duration)\n  // })()\n  const BATCH_SIZE = 50; // Typically around 150ms for 6x slowdown in Chrome for above benchmark\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    let lastKey;\n\n    const processNextBatch = () => {\n      emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = e => {\n        const results = e.target.result;\n        for (const result of results) {\n          lastKey = result.unicode;\n          if (predicate(result)) {\n            return cb(result)\n          }\n        }\n        if (results.length < BATCH_SIZE) {\n          return cb()\n        }\n        processNextBatch();\n      };\n    };\n    processNextBatch();\n  })\n}\n\nasync function loadData (db, emojiData, url, eTag) {\n  try {\n    const transformedData = transformEmojiData(emojiData);\n    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, ([emojiStore, metaStore], txn) => {\n      let oldETag;\n      let oldUrl;\n      let todo = 0;\n\n      function checkFetched () {\n        if (++todo === 2) { // 2 requests made\n          onFetched();\n        }\n      }\n\n      function onFetched () {\n        if (oldETag === eTag && oldUrl === url) {\n          // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n          return\n        }\n        // delete old data\n        emojiStore.clear();\n        // insert new data\n        for (const data of transformedData) {\n          emojiStore.put(data);\n        }\n        metaStore.put(eTag, KEY_ETAG);\n        metaStore.put(url, KEY_URL);\n        commit(txn);\n      }\n\n      getIDB(metaStore, KEY_ETAG, result => {\n        oldETag = result;\n        checkFetched();\n      });\n\n      getIDB(metaStore, KEY_URL, result => {\n        oldUrl = result;\n        checkFetched();\n      });\n    });\n  } finally {\n  }\n}\n\nasync function getEmojiByGroup (db, group) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);\n    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);\n  })\n}\n\nasync function getEmojiBySearchQuery (db, query) {\n  const tokens = normalizeTokens(extractTokens(query));\n\n  if (!tokens.length) {\n    return []\n  }\n\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {\n    // get all results that contain all tokens (i.e. an AND query)\n    const intermediateResults = [];\n\n    const checkDone = () => {\n      if (intermediateResults.length === tokens.length) {\n        onDone();\n      }\n    };\n\n    const onDone = () => {\n      const results = findCommonMembers(intermediateResults, _ => _.unicode);\n      cb(results.sort((a, b) => a.order < b.order ? -1 : 1));\n    };\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const range = i === tokens.length - 1\n        ? IDBKeyRange.bound(token, token + '\\uffff', false, true) // treat last token as a prefix search\n        : IDBKeyRange.only(token); // treat all other tokens as an exact match\n      getAllIDB(emojiStore.index(INDEX_TOKENS), range, result => {\n        intermediateResults.push(result);\n        checkDone();\n      });\n    }\n  })\n}\n\n// This could have been implemented as an IDB index on shortcodes, but it seemed wasteful to do that\n// when we can already query by tokens and this will give us what we're looking for 99.9% of the time\nasync function getEmojiByShortcode (db, shortcode) {\n  const emojis = await getEmojiBySearchQuery(db, shortcode);\n\n  // In very rare cases (e.g. the shortcode \"v\" as in \"v for victory\"), we cannot search because\n  // there are no usable tokens (too short in this case). In that case, we have to do an inefficient\n  // full-database scan, which I believe is an acceptable tradeoff for not having to have an extra\n  // index on shortcodes.\n\n  if (!emojis.length) {\n    const predicate = _ => ((_.shortcodes || []).includes(shortcode.toLowerCase()));\n    return (await doFullDatabaseScanForSingleResult(db, predicate)) || null\n  }\n\n  return emojis.filter(_ => {\n    const lowerShortcodes = (_.shortcodes || []).map(_ => _.toLowerCase());\n    return lowerShortcodes.includes(shortcode.toLowerCase())\n  })[0] || null\n}\n\nasync function getEmojiByUnicode (db, unicode) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => (\n    getIDB(emojiStore, unicode, result => {\n      if (result) {\n        return cb(result)\n      }\n      getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, result => cb(result || null));\n    })\n  ))\n}\n\nfunction get (db, storeName, key) {\n  return dbPromise(db, storeName, MODE_READONLY, (store, txn, cb) => (\n    getIDB(store, key, cb)\n  ))\n}\n\nfunction set (db, storeName, key, value) {\n  return dbPromise(db, storeName, MODE_READWRITE, (store, txn) => {\n    store.put(value, key);\n    commit(txn);\n  })\n}\n\nfunction incrementFavoriteEmojiCount (db, unicode) {\n  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store, txn) => (\n    getIDB(store, unicode, result => {\n      store.put((result || 0) + 1, unicode);\n      commit(txn);\n    })\n  ))\n}\n\nfunction getTopFavoriteEmoji (db, customEmojiIndex, limit) {\n  if (limit === 0) {\n    return []\n  }\n  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, ([favoritesStore, emojiStore], txn, cb) => {\n    const results = [];\n    favoritesStore.index(INDEX_COUNT).openCursor(undefined, 'prev').onsuccess = e => {\n      const cursor = e.target.result;\n      if (!cursor) { // no more results\n        return cb(results)\n      }\n\n      function addResult (result) {\n        results.push(result);\n        if (results.length === limit) {\n          return cb(results) // done, reached the limit\n        }\n        cursor.continue();\n      }\n\n      const unicodeOrName = cursor.primaryKey;\n      const custom = customEmojiIndex.byName(unicodeOrName);\n      if (custom) {\n        return addResult(custom)\n      }\n      // This could be done in parallel (i.e. make the cursor and the get()s parallelized),\n      // but my testing suggests it's not actually faster.\n      getIDB(emojiStore, unicodeOrName, emoji => {\n        if (emoji) {\n          return addResult(emoji)\n        }\n        // emoji not found somehow, ignore (may happen if custom emoji change)\n        cursor.continue();\n      });\n    };\n  })\n}\n\n// trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\n\nconst CODA_MARKER = ''; // marks the end of the string\n\nfunction trie (arr, itemToTokens) {\n  const map = new Map();\n  for (const item of arr) {\n    const tokens = itemToTokens(item);\n    for (const token of tokens) {\n      let currentMap = map;\n      for (let i = 0; i < token.length; i++) {\n        const char = token.charAt(i);\n        let nextMap = currentMap.get(char);\n        if (!nextMap) {\n          nextMap = new Map();\n          currentMap.set(char, nextMap);\n        }\n        currentMap = nextMap;\n      }\n      let valuesAtCoda = currentMap.get(CODA_MARKER);\n      if (!valuesAtCoda) {\n        valuesAtCoda = [];\n        currentMap.set(CODA_MARKER, valuesAtCoda);\n      }\n      valuesAtCoda.push(item);\n    }\n  }\n\n  const search = (query, exact) => {\n    let currentMap = map;\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charAt(i);\n      const nextMap = currentMap.get(char);\n      if (nextMap) {\n        currentMap = nextMap;\n      } else {\n        return []\n      }\n    }\n\n    if (exact) {\n      const results = currentMap.get(CODA_MARKER);\n      return results || []\n    }\n\n    const results = [];\n    // traverse\n    const queue = [currentMap];\n    while (queue.length) {\n      const currentMap = queue.shift();\n      const entriesSortedByKey = [...currentMap.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);\n      for (const [key, value] of entriesSortedByKey) {\n        if (key === CODA_MARKER) { // CODA_MARKER always comes first; it's the empty string\n          results.push(...value);\n        } else {\n          queue.push(value);\n        }\n      }\n    }\n    return results\n  };\n\n  return search\n}\n\nconst requiredKeys$1 = [\n  'name',\n  'url'\n];\n\nfunction assertCustomEmojis (customEmojis) {\n  const isArray = customEmojis && Array.isArray(customEmojis);\n  const firstItemIsFaulty = isArray &&\n    customEmojis.length &&\n    (!customEmojis[0] || requiredKeys$1.some(key => !(key in customEmojis[0])));\n  if (!isArray || firstItemIsFaulty) {\n    throw new Error('Custom emojis are in the wrong format')\n  }\n}\n\nfunction customEmojiIndex (customEmojis) {\n  assertCustomEmojis(customEmojis);\n\n  const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;\n\n  //\n  // all()\n  //\n  const all = customEmojis.sort(sortByName);\n\n  //\n  // search()\n  //\n  const emojiToTokens = emoji => (\n    [...new Set((emoji.shortcodes || []).map(shortcode => extractTokens(shortcode)).flat())]\n  );\n  const searchTrie = trie(customEmojis, emojiToTokens);\n  const searchByExactMatch = _ => searchTrie(_, true);\n  const searchByPrefix = _ => searchTrie(_, false);\n\n  // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n  // is treated as a prefix search, but every other one is treated as an exact match.\n  // Then we AND the results together\n  const search = query => {\n    const tokens = extractTokens(query);\n    const intermediateResults = tokens.map((token, i) => (\n      (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token)\n    ));\n    return findCommonMembers(intermediateResults, _ => _.name).sort(sortByName)\n  };\n\n  //\n  // byShortcode, byName\n  //\n  const shortcodeToEmoji = new Map();\n  const nameToEmoji = new Map();\n  for (const customEmoji of customEmojis) {\n    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n    for (const shortcode of (customEmoji.shortcodes || [])) {\n      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n  }\n\n  const byShortcode = shortcode => shortcodeToEmoji.get(shortcode.toLowerCase());\n  const byName = name => nameToEmoji.get(name.toLowerCase());\n\n  return {\n    all,\n    search,\n    byShortcode,\n    byName\n  }\n}\n\n// remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\nfunction cleanEmoji (emoji) {\n  if (!emoji) {\n    return emoji\n  }\n  delete emoji.tokens;\n  if (emoji.skinTones) {\n    const len = emoji.skinTones.length;\n    emoji.skins = Array(len);\n    for (let i = 0; i < len; i++) {\n      emoji.skins[i] = {\n        tone: emoji.skinTones[i],\n        unicode: emoji.skinUnicodes[i],\n        version: emoji.skinVersions[i]\n      };\n    }\n    delete emoji.skinTones;\n    delete emoji.skinUnicodes;\n    delete emoji.skinVersions;\n  }\n  return emoji\n}\n\nfunction warnETag (eTag) {\n  if (!eTag) {\n    console.warn('emoji-picker-element is more efficient if the dataSource server exposes an ETag header.');\n  }\n}\n\nconst requiredKeys = [\n  'annotation',\n  'emoji',\n  'group',\n  'order',\n  'tags',\n  'version'\n];\n\nfunction assertEmojiData (emojiData) {\n  if (!emojiData ||\n    !Array.isArray(emojiData) ||\n    !emojiData[0] ||\n    (typeof emojiData[0] !== 'object') ||\n    requiredKeys.some(key => (!(key in emojiData[0])))) {\n    throw new Error('Emoji data is in the wrong format')\n  }\n}\n\nfunction assertStatus (response, dataSource) {\n  if (Math.floor(response.status / 100) !== 2) {\n    throw new Error('Failed to fetch: ' + dataSource + ':  ' + response.status)\n  }\n}\n\nasync function getETag (dataSource) {\n  const response = await fetch(dataSource, { method: 'HEAD' });\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  return eTag\n}\n\nasync function getETagAndData (dataSource) {\n  const response = await fetch(dataSource);\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  const emojiData = await response.json();\n  assertEmojiData(emojiData);\n  return [eTag, emojiData]\n}\n\n// TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n/**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */\nfunction arrayBufferToBinaryString(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    var length = bytes.byteLength;\n    var i = -1;\n    while (++i < length) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */\nfunction binaryStringToArrayBuffer(binary) {\n    var length = binary.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    var i = -1;\n    while (++i < length) {\n        arr[i] = binary.charCodeAt(i);\n    }\n    return buf;\n}\n\n// generate a checksum based on the stringified JSON\nasync function jsonChecksum (object) {\n  const inString = JSON.stringify(object);\n  const inBuffer = binaryStringToArrayBuffer(inString);\n  // this does not need to be cryptographically secure, SHA-1 is fine\n  const outBuffer = await crypto.subtle.digest('SHA-1', inBuffer);\n  const outBinString = arrayBufferToBinaryString(outBuffer);\n  const res = btoa(outBinString);\n  return res\n}\n\nasync function checkForUpdates (db, dataSource) {\n  // just do a simple HEAD request first to see if the eTags match\n  let emojiData;\n  let eTag = await getETag(dataSource);\n  if (!eTag) { // work around lack of ETag/Access-Control-Expose-Headers\n    const eTagAndData = await getETagAndData(dataSource);\n    eTag = eTagAndData[0];\n    emojiData = eTagAndData[1];\n    if (!eTag) {\n      eTag = await jsonChecksum(emojiData);\n    }\n  }\n  if (await hasData(db, dataSource, eTag)) ; else {\n    if (!emojiData) {\n      const eTagAndData = await getETagAndData(dataSource);\n      emojiData = eTagAndData[1];\n    }\n    await loadData(db, emojiData, dataSource, eTag);\n  }\n}\n\nasync function loadDataForFirstTime (db, dataSource) {\n  let [eTag, emojiData] = await getETagAndData(dataSource);\n  if (!eTag) {\n    // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await jsonChecksum(emojiData);\n  }\n\n  await loadData(db, emojiData, dataSource, eTag);\n}\n\nclass Database {\n  constructor ({ dataSource = DEFAULT_DATA_SOURCE, locale = DEFAULT_LOCALE, customEmoji = [] } = {}) {\n    this.dataSource = dataSource;\n    this.locale = locale;\n    this._dbName = `emoji-picker-element-${this.locale}`;\n    this._db = undefined;\n    this._lazyUpdate = undefined;\n    this._custom = customEmojiIndex(customEmoji);\n\n    this._clear = this._clear.bind(this);\n    this._ready = this._init();\n  }\n\n  async _init () {\n    const db = this._db = await openDatabase(this._dbName);\n\n    addOnCloseListener(this._dbName, this._clear);\n    const dataSource = this.dataSource;\n    const empty = await isEmpty(db);\n\n    if (empty) {\n      await loadDataForFirstTime(db, dataSource);\n    } else { // offline-first - do an update asynchronously\n      this._lazyUpdate = checkForUpdates(db, dataSource);\n    }\n  }\n\n  async ready () {\n    const checkReady = async () => {\n      if (!this._ready) {\n        this._ready = this._init();\n      }\n      return this._ready\n    };\n    await checkReady();\n    // There's a possibility of a race condition where the element gets added, removed, and then added again\n    // with a particular timing, which would set the _db to undefined.\n    // We *could* do a while loop here, but that seems excessive and could lead to an infinite loop.\n    if (!this._db) {\n      await checkReady();\n    }\n  }\n\n  async getEmojiByGroup (group) {\n    assertNumber(group);\n    await this.ready();\n    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji)\n  }\n\n  async getEmojiBySearchQuery (query) {\n    assertNonEmptyString(query);\n    await this.ready();\n    const customs = this._custom.search(query);\n    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);\n    return [\n      ...customs,\n      ...natives\n    ]\n  }\n\n  async getEmojiByShortcode (shortcode) {\n    assertNonEmptyString(shortcode);\n    await this.ready();\n    const custom = this._custom.byShortcode(shortcode);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode))\n  }\n\n  async getEmojiByUnicodeOrName (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    const custom = this._custom.byName(unicodeOrName);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName))\n  }\n\n  async getPreferredSkinTone () {\n    await this.ready();\n    return (await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE)) || 0\n  }\n\n  async setPreferredSkinTone (skinTone) {\n    assertNumber(skinTone);\n    await this.ready();\n    return set(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone)\n  }\n\n  async incrementFavoriteEmojiCount (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    return incrementFavoriteEmojiCount(this._db, unicodeOrName)\n  }\n\n  async getTopFavoriteEmoji (limit) {\n    assertNumber(limit);\n    await this.ready();\n    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji)\n  }\n\n  set customEmoji (customEmojis) {\n    this._custom = customEmojiIndex(customEmojis);\n  }\n\n  get customEmoji () {\n    return this._custom.all\n  }\n\n  async _shutdown () {\n    await this.ready(); // reopen if we've already been closed/deleted\n    try {\n      await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n    } catch (err) { /* ignore network errors (offline-first) */ }\n  }\n\n  // clear references to IDB, e.g. during a close event\n  _clear () {\n    // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n    // The memory leak tests prove this is unnecessary. It's because:\n    // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n    // 2) we clear the manual close listeners in databaseLifecycle.js.\n    this._db = this._ready = this._lazyUpdate = undefined;\n  }\n\n  async close () {\n    await this._shutdown();\n    await closeDatabase(this._dbName);\n  }\n\n  async delete () {\n    await this._shutdown();\n    await deleteDatabase(this._dbName);\n  }\n}\n\nexport { Database as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}